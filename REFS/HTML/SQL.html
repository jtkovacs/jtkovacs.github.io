<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <meta content="text/css" http-equiv="Content-Style-Type"/>
  <meta content="pandoc" name="generator"/>
  <title>
  </title>
  <link href="refs.css" rel="stylesheet" type="text/css"/>
  <style type="text/css">
   div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
 </head>
 <body>
  <p id="path">
   <a href="../../pkb.html">
    https://jtkovacs.github.io/pkb.html
   </a>
   &gt;
   <a href="https://jtkovacs.github.io/REFS/HTML/SQL.html">
    https://jtkovacs.github.io/REFS/HTML/SQL.html
   </a>
   &gt; 2286 words
  </p>
  <table class="TOC">
   <tr>
    <td>
     <ul>
      <li>
       <a href="#what-is-sql?">
        What is SQL?
       </a>
       <ul>
        <li>
         <a href="#notation-and-style-guide">
          Notation and style guide
         </a>
        </li>
        <li>
         <a href="#...-a-data-definition-language">
          ... a data definition language
         </a>
         <ul>
          <li>
           <a href="#manage-databases">
            Manage databases
           </a>
          </li>
          <li>
           <a href="#manage-tables">
            Manage tables
           </a>
          </li>
          <li>
           <a href="#manage-views">
            Manage views
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#...-a-data-manipulation-language">
          ... a data manipulation language
         </a>
        </li>
        <li>
         <a href="#generic-query-form">
          Generic query form
         </a>
        </li>
        <li>
         <a href="#relational-algebra">
          Relational algebra
         </a>
         <ul>
          <li>
           <a href="#joins">
            JOINs
           </a>
          </li>
          <li>
           <a href="#set-operations">
            Set operations
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#subqueries">
          Subqueries
         </a>
        </li>
        <li>
         <a href="#grouping-&amp;-aggregation">
          Grouping &amp; aggregation
         </a>
         <ul>
          <li>
           <a href="#check-for-inclusion">
            Check for inclusion
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#sources">
        SOURCES
       </a>
       <ul>
        <li>
         <a href="#references">
          References
         </a>
        </li>
        <li>
         <a href="#archive">
          Archive
         </a>
        </li>
        <li>
         <a href="#inbox">
          Inbox
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </td>
   </tr>
  </table>
  <h1>
   <a name="what-is-sql?">
    What is SQL?
   </a>
  </h1>
  <p>
   SQL is the standardized language used to access a database. SQL language provides for: (1) data definition/DDL statements that help you define the database and its objects; (2) data manipulation/DML statements that allow you to update and query data; (3) data control, allows you to grant the permissions to a user to access a certain data in the database.
  </p>
  <h2>
   <a name="notation-and-style-guide">
    Notation and style guide
   </a>
  </h2>
  <ul>
   <li>
    all commands end with semicolon
   </li>
   <li>
    by convention, commands are CAPITALIZED
   </li>
   <li>
    NULL means a cell is unpopulated; NULL = NULL → F
   </li>
   <li>
    ORDER is very important! e.g. WHERE must precede GROUP BY; GROUP BY must precede HAVING
   </li>
   <li>
    notation: table (field1, field2, … , fieldn)
   </li>
   <li>
    comments: -- comment, /* comment comment */
   </li>
   <li>
    mathematical operators: +,-,/,*
   </li>
   <li>
    SELECT GPA, GPA*(size_HS/1000) AS scaleGPA FROM …
   </li>
   <li>
    gives row dimension of table: SELECT count(*) FROM tname;
   </li>
  </ul>
  <h2>
   <a name="...-a-data-definition-language">
    ... a data definition language
   </a>
  </h2>
  <h3>
   <a name="manage-databases">
    Manage databases
   </a>
  </h3>
  <h3>
   <a name="manage-tables">
    Manage tables
   </a>
  </h3>
  <p>
   Datatypes: http://www.w3schools.com/sql/sql_datatypes.asp, but they will depend on DBMS
  </p>
  <ul>
   <li>
    int stores numbers from -217483648 to 217483647
   </li>
   <li>
    double &amp; real allow scientific notation: 2.5e4
   </li>
   <li>
    decimal is good for money: DECIMAL(5,2) has 5 digits, of which 2 are after the decimal point
   </li>
   <li>
    varchar(max_length), char(fixed_length) , clob/text is unlimited length , boolean is TRUE/FALSE
   </li>
   <li>
    date is ‘yyyy-MM-dd’, time is ‘hh:mm:ss’, datetime or timestamp is ‘yyyy-MM-dd hh:mm:ss’
   </li>
  </ul>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="co">-- create table: </span>

<span class="kw">CREATE</span> <span class="kw">TABLE</span> t (<span class="kw">id</span> <span class="dt">INT</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span>, col1 <span class="kw">TYPE</span>(<span class="kw">size</span>), col2 <span class="kw">TYPE</span> <span class="kw">constraint</span> <span class="kw">constraint</span>, col3 <span class="kw">FOREIGN</span> <span class="kw">KEY</span> <span class="kw">REFERENCES</span> other_table(fieldname), col4 <span class="kw">DEFAULT</span> ‘value’, … ); 
<span class="co">-- constraints: NOT NULL, UNIQUE, CHECK, DEFAULT</span>
<span class="co">-- autopopulate date: CREATE TABLE tname (order_date date DEFAULT getdate()); </span>
<span class="kw">CREATE</span> <span class="kw">TABLE</span> tname (… <span class="kw">UNIQUE</span> (col1, col2, …) … );
<span class="kw">CREATE</span> <span class="kw">TABLE</span> tname ( … <span class="dt">year</span> <span class="dt">INT</span> <span class="kw">CHECK</span> (year&gt;<span class="dv">1950</span> <span class="kw">AND</span> year&lt;<span class="dv">1980</span>)) …)
<span class="kw">CREATE</span> <span class="kw">TABLE</span> tname (... <span class="kw">CHECK</span> (price/hours &lt; <span class="dv">20</span>)); 

<span class="co">-- composite PK: </span>
<span class="kw">CREATE</span> <span class="kw">TABLE</span> t (name <span class="dt">int</span>, <span class="dt">date</span> <span class="dt">int</span>, <span class="kw">PRIMARY</span> <span class="kw">KEY</span>(name,<span class="dt">date</span>));
<span class="co">-- foreign key:</span>
… <span class="kw">FOREIGN</span> <span class="kw">KEY</span>(c1) <span class="kw">REFERENCES</span> t1(c1), <span class="kw">FOREIGN</span> <span class="kw">KEY</span>(c2) <span class="kw">REFERENCES</span> t2(c1));
… <span class="kw">REFERENCES</span> … <span class="kw">ON</span> <span class="kw">DELETE</span> [action] <span class="kw">ON</span> <span class="kw">UPDATE</span> [action]

<span class="co">-- CASCADE: when the referenced row is deleted or updated, the respective rows of the referencing table will be deleted or updated.</span>
<span class="co">-- NO ACTION: do nothing to the the referenced row</span>
<span class="co">-- SET NULL: the values of the affected rows are set to NULLs</span>
<span class="co">-- SET DEFAULT: the values of the affected rows are set to their default values</span>

<span class="co">-- multicolumn foreign key: </span>
… <span class="kw">FOREIGN</span> <span class="kw">KEY</span>(c1, c2) <span class="kw">REFERENCES</span> t2(c1, c2)); 

<span class="co">-- autoincrement PK:</span>
… <span class="kw">id</span> <span class="dt">INT</span> IDENTITY(#start, #inc) <span class="kw">PRIMARY</span> <span class="kw">KEY</span>, ...
… <span class="kw">id</span> <span class="dt">INT</span> AUTO_INCREMENT(#start, #inc) <span class="kw">PRIMARY</span> <span class="kw">KEY</span>, …

<span class="co">-- create PK</span>
<span class="kw">CREATE</span> <span class="kw">SEQUENCE</span> name <span class="kw">START</span> <span class="kw">WITH</span> # <span class="kw">INCREMENT</span> <span class="kw">BY</span> #; 
<span class="kw">CREATE</span> <span class="kw">TABLE</span> t ( … <span class="kw">id</span> <span class="kw">DEFAULT</span> nextval(‘name’) <span class="kw">PRIMARY</span> <span class="kw">KEY</span> … );

<span class="co">--- delete table: </span>
<span class="kw">DROP</span> <span class="kw">TABLE</span> tname;
<span class="kw">DROP</span> <span class="kw">DATABASE</span> dname;
<span class="kw">TRUNCATE</span> <span class="kw">TABLE</span> tname;

<span class="co">--- add records: when SELECT is used as an expression in these kinds of queries, it needs to return only one column; </span>
<span class="co">--- so it sometimes helps to create a new identifier, say c1*c2*c3</span>
<span class="kw">INSERT</span> <span class="kw">INTO</span> tname <span class="kw">VALUES</span> (key#, ‘string_value’, <span class="kw">NULL</span>, ...);

<span class="co">--- if select returns same schema: </span>
<span class="kw">INSERT</span> <span class="kw">INTO</span> t  (c1, c2) <span class="kw">SELECT</span> c1, c2 … 

<span class="co">--- add fields to confom to schema: </span>
<span class="kw">SELECT</span> col, <span class="dv">12</span>, <span class="kw">NULL</span>
<span class="kw">INSERT</span> <span class="kw">INTO</span> t (col1, colx) <span class="kw">VALUES</span> (val, val), (val, val), (val, val)

<span class="co">--- delete records: </span>
<span class="co">--- some implementations disallow condition statements with a subquery that includes the affected table</span>
<span class="kw">DELETE</span> <span class="kw">FROM</span> tname <span class="kw">WHERE</span> … 

<span class="co">--- delete all records: </span>
<span class="kw">DELETE</span> <span class="kw">FROM</span> <span class="kw">table</span>;

<span class="co">--- update records:</span>
<span class="kw">UPDATE</span> tname <span class="kw">SET</span> c1=value/subquery, c2=value/subquery <span class="kw">WHERE</span> …</code></pre>
  </div>
  <h3>
   <a name="manage-views">
    Manage views
   </a>
  </h3>
  <p>
   view data is not stored physically; every time you retrieve data from the view, the database reruns the underlying query. most databases don't allow inserting new data or updating existing data in views.
  </p>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">create</span> a view: <span class="kw">CREATE</span> <span class="kw">VIEW</span> vname <span class="kw">AS</span> [<span class="kw">query</span>];
<span class="kw">use</span> a view: <span class="kw">SELECT</span> * <span class="kw">FROM</span> vname;
<span class="kw">DROP</span> <span class="kw">VIEW</span> vname;</code></pre>
  </div>
  <h2>
   <a name="...-a-data-manipulation-language">
    ... a data manipulation language
   </a>
  </h2>
  <h2>
   <a name="generic-query-form">
    Generic query form
   </a>
  </h2>
  <p>
   Match the following clauses with its definition:
  </p>
  <ul>
   <li>
    SELECT: Columns to appear in result-set
   </li>
   <li>
    FROM: Specifies table(s) holding desired columns
   </li>
   <li>
    WHERE: Allows user to filter rows returned
   </li>
   <li>
    GROUP BY: Clusters rows by common column value
   </li>
   <li>
    HAVING: Filters GROUP BY clause
   </li>
   <li>
    ORDER BY: Sorts the output of the results-set in a desired sequence
   </li>
  </ul>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> c1,c2 <span class="kw">FROM</span> tname <span class="kw">WHERE</span> ... ; <span class="kw">SELECT</span> * <span class="kw">FROM</span> tname;
operators: &lt;, &gt;, &lt;=, &gt;=, !=, ==, &lt;&gt;, <span class="kw">OR</span>, <span class="kw">AND</span>, <span class="kw">NOT</span>, <span class="kw">BETWEEN</span>, <span class="kw">IS</span>, <span class="kw">NULL</span>, <span class="kw">EXISTS</span>, <span class="kw">ANY</span>, <span class="kw">ALL</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> tname <span class="kw">WHERE</span> cname=numeric;
<span class="kw">SELECT</span> * <span class="kw">FROM</span> tname <span class="kw">WHERE</span> cname=‘string’;
<span class="kw">SELECT</span> c1,c2 <span class="kw">FROM</span> t <span class="kw">WHERE</span> c1&gt;= <span class="fu">value</span> <span class="kw">OR</span> c2=value;
<span class="kw">SELECT</span> … <span class="kw">FROM</span> … <span class="kw">WHERE</span> (complex_condition1) <span class="kw">AND</span> (complex_condition2)
<span class="kw">SELECT</span> * <span class="kw">FROM</span> t <span class="kw">WHERE</span> c <span class="kw">BETWEEN</span> condition1 <span class="kw">AND</span> condition2;
dep. <span class="kw">on</span> implementation, may <span class="kw">not</span> include endpoints
… <span class="kw">NOT</span> <span class="kw">BETWEEN</span> …
<span class="kw">IS</span> <span class="kw">NULL</span>, <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span>
<span class="kw">EXISTS</span> checks whether a subquery <span class="kw">is</span> <span class="kw">empty</span>; its expressive <span class="fu">power</span> encompasses:
… = <span class="kw">ALL</span> (<span class="kw">SELECT</span> …), … != <span class="kw">ALL</span> (<span class="kw">SELECT</span> …)
… = <span class="kw">ANY</span> (<span class="kw">SELECT</span> …), … != <span class="kw">ANY</span> (<span class="kw">SELECT</span> …)
fuzzy match: 
multiple char: <span class="kw">SELECT</span> * <span class="kw">FROM</span> … <span class="kw">WHERE</span> c <span class="kw">LIKE</span> ‘%string%’;
<span class="dt">single</span> char: <span class="kw">SELECT</span> * <span class="kw">FROM</span> … <span class="kw">WHERE</span> c <span class="kw">LIKE</span> ‘_tringvalue’;</code></pre>
  </div>
  <h2>
   <a name="relational-algebra">
    Relational algebra
   </a>
  </h2>
  <p>
   Relational algebra is the formal math underlying SQL. Unlike SQL, it’s set-based, so it automatically removes duplicates from its ‘results’. RA operators are applied to expression, - trees, or assignment statements:
  </p>
  <ul>
   <li>
    select rows: σcondition ∧ condition tname
   </li>
   <li>
    project columns: πcol_name, col_name
   </li>
   <li>
    compose: πcol_name, col_name(σcondition ∧ condition )
   </li>
   <li>
    operators:
   </li>
   <li>
    and, ∧; or, ∨; union, ∪
   </li>
   <li>
    cross product, x: union of schemas, every possible combo of tuples (ntuples(A)*ntuples(B))
   </li>
   <li>
    natural join, ⋈: match cols &amp; drop duplicates; A⋈B ≡ πschema(A) ∪ πschema(B)(σA.col = B.col ∧ … (AxB))
   </li>
   <li>
    theta join: A ⋈θ B where A⋈θB ≡ σθ(AxB); default join for many DBMS
   </li>
   <li>
    rename, ⍴Name(cname, …) (A): unifies schemas to satisfy conditions of set operators and to allow disambiguation in self-joins; ⍴Name(A), ⍴cname, … (A)
   </li>
   <li>
    difference, -
   </li>
   <li>
    intersection, ⋂ where A⋂B ≡ A - (A-B), A⋂B ≡ A⋈B
   </li>
   <li>
    symmetric difference: (A-B)∪(B-A)
   </li>
  </ul>
  <h3>
   <a name="joins">
    JOINs
   </a>
  </h3>
  <ul>
   <li>
    http://www.vertabelo.com/blog/technical-articles/sql-joins
   </li>
   <li>
    http://thomaslarock.com/2012/04/real-world-sql-join-examples/
   </li>
   <li>
    http://sqlmag.com/t-sql/t-sql-join-types
   </li>
  </ul>
  <p>
   Which of the following are characteristics of a JOIN?
  </p>
  <ul>
   <li>
    Data is automatically sorted by the first column
   </li>
   <li>
    Tables are JOINed via PK/FK relationships
   </li>
   <li>
    More than two tables can be JOINed in one query
   </li>
   <li>
    The keyword GROUP is mandatory
   </li>
  </ul>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql">returns, <span class="kw">for</span> two mxn <span class="kw">tables</span>, a <span class="kw">table</span> <span class="kw">of</span> dim (m1*m2)x(n1+n2): <span class="kw">SELECT</span> * <span class="kw">FROM</span> t1, t2
<span class="kw">join</span> via select: <span class="kw">SELECT</span> * <span class="kw">FROM</span> table1,table2 <span class="kw">WHERE</span> table1.col = table2.col;
<span class="kw">for</span> joins note that, <span class="kw">in</span> SQL classic versus <span class="kw">the</span> graphic: 
<span class="kw">the</span> <span class="kw">default</span> <span class="kw">JOIN</span> <span class="kw">is</span> <span class="kw">inner</span> <span class="kw">join</span>
<span class="kw">FULL</span> <span class="kw">JOIN</span> doesn’t need “outer” clause
<span class="kw">NATURAL</span> <span class="kw">JOIN</span> doesn’t need “on” clause; good <span class="kw">for</span> well-built db 
aliases <span class="kw">enable</span> self-joins: <span class="kw">SELECT</span> c1 <span class="kw">AS</span> ... <span class="kw">FROM</span> t1 <span class="kw">AS</span> ... <span class="kw">JOIN</span> t2 <span class="kw">AS</span> … <span class="kw">ON</span> …
<span class="kw">SELECT</span> * <span class="kw">FROM</span> Student S1, Student S2 <span class="kw">WHERE</span> S1.GPA = S2.GPA <span class="kw">AND</span> S1.sID &gt; S2.sID
multiple tables: <span class="kw">SELECT</span> * <span class="kw">FROM</span> t1 <span class="kw">JOIN</span> t1 <span class="kw">ON</span> … <span class="kw">JOIN</span> t3 <span class="kw">ON</span> … <span class="kw">WHERE</span> … 
<span class="kw">set</span> operators: let you <span class="kw">query</span> n <span class="kw">tables</span> <span class="kw">and</span> show <span class="kw">the</span> results <span class="kw">as</span> one <span class="kw">table</span>, provided <span class="kw">both</span> <span class="kw">tables</span> have <span class="kw">the</span> same #cols <span class="kw">of</span> <span class="kw">the</span> same <span class="kw">type</span>
removes duplicates: <span class="kw">SELECT</span> … <span class="kw">FROM</span> … <span class="kw">UNION</span> <span class="kw">SELECT</span> … <span class="kw">FROM</span> …; 
<span class="kw">multiset</span> operator: <span class="kw">SELECT</span> … <span class="kw">FROM</span> … <span class="kw">UNION</span> <span class="kw">ALL</span> <span class="kw">SELECT</span> … <span class="kw">FROM</span> ...;
<span class="kw">SELECT</span> … <span class="kw">FROM</span> … <span class="kw">INTERSECT</span> <span class="kw">SELECT</span> … <span class="kw">FROM</span> ...;
<span class="kw">SELECT</span> * <span class="kw">FROM</span> &lt;self_join&gt; <span class="kw">WHERE</span> &lt;join_cndn&gt; <span class="kw">AND</span> &lt;select_cndn&gt;
except: <span class="kw">SELECT</span> ... <span class="kw">FROM</span> ... <span class="kw">EXCEPT</span> <span class="kw">SELECT</span> … FROM...;
<span class="kw">SELECT</span> * <span class="kw">FROM</span> ... <span class="kw">WHERE</span> * <span class="kw">IN</span> (subquery) <span class="kw">AND</span> * <span class="kw">NOT</span> <span class="kw">IN</span> (subquery) </code></pre>
  </div>
  <div class="figure">
   <img alt="Set theory" src="set-theory.png"/>
   <p class="caption">
    Set theory
   </p>
  </div>
  <h3>
   <a name="set-operations">
    Set operations
   </a>
  </h3>
  <h2>
   <a name="subqueries">
    Subqueries
   </a>
  </h2>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql">SUBQUERIES … <span class="kw">the</span> <span class="kw">database</span> will <span class="fu">first</span> <span class="kw">check</span> <span class="kw">the</span> subquery <span class="kw">then</span> <span class="kw">check</span> <span class="kw">the</span> final <span class="kw">query</span>, e.g.: <span class="kw">SELECT</span> name <span class="kw">FROM</span> city <span class="kw">WHERE</span> rating = (<span class="kw">SELECT</span> rating <span class="kw">FROM</span> city <span class="kw">WHERE</span> name = <span class="st">'Paris'</span>);
subqueries can be <span class="kw">in</span> <span class="kw">the</span> <span class="kw">WHERE</span> clause …
<span class="kw">in</span> <span class="kw">FROM</span> clause, reducing need <span class="kw">for</span> calculation <span class="kw">in</span> <span class="kw">SELECT</span> <span class="kw">and</span> <span class="kw">WHERE</span> ..
<span class="kw">and</span> <span class="kw">in</span> <span class="kw">the</span> <span class="kw">SELECT</span> clause 
used <span class="kw">as</span> an expression, it<span class="st">'s important the subquery return exactly one col </span>
<span class="st">compare with a set of values instead of a single value: … WHERE … IN (subquery);</span>
<span class="st">correlated subqueries, i.e. dependent on the main query; subqueries can use tables from the main query, but the main query can'</span>t <span class="kw">use</span> <span class="kw">tables</span> <span class="kw">from</span> <span class="kw">the</span> subquery. 
good <span class="kw">for</span> debugging, e.g. <span class="kw">SELECT</span> * <span class="kw">FROM</span> country <span class="kw">WHERE</span> area &lt;= (<span class="kw">SELECT</span> <span class="fu">min</span>(area) <span class="kw">FROM</span> city <span class="kw">WHERE</span> city.country_id = country.id);
<span class="kw">use</span> aliases <span class="kw">for</span> self-correlated subqueries: <span class="kw">SELECT</span> * <span class="kw">FROM</span> city <span class="kw">as</span> c1 <span class="kw">WHERE</span> c1.rating &gt; (<span class="kw">SELECT</span> <span class="fu">avg</span>(c2.rating) <span class="kw">FROM</span> city <span class="kw">AS</span> c2 <span class="kw">WHERE</span> c1.country_id=c2.country_id);
<span class="kw">exists</span> operator: <span class="kw">SELECT</span> * <span class="kw">FROM</span> country <span class="kw">WHERE</span> <span class="kw">EXISTS</span> (<span class="kw">SELECT</span> * <span class="kw">FROM</span> mountain <span class="kw">WHERE</span> country.id = mountain.country_id);</code></pre>
  </div>
  <h2>
   <a name="grouping-&amp;-aggregation">
    Grouping &amp; aggregation
   </a>
  </h2>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql">skip: <span class="kw">SELECT</span> &lt;c&gt; <span class="kw">FROM</span> &lt;t&gt; <span class="kw">LIMIT</span> &lt;# <span class="kw">of</span> rows&gt; OFFSET &lt;skipped rows&gt;;
<span class="kw">SELECT</span> &lt;c&gt; <span class="kw">FROM</span> &lt;t&gt; <span class="kw">LIMIT</span> &lt;skipped rows&gt;, &lt;# <span class="kw">of</span> rows&gt;; 
<span class="kw">SELECT</span> &lt;c&gt; <span class="kw">FROM</span> &lt;t&gt; OFFSET &lt;skipped rows&gt; <span class="kw">ROWS</span> FETCH <span class="kw">NEXT</span> &lt;#&gt; <span class="kw">ROWS</span> <span class="kw">ONLY</span>;
<span class="kw">summary</span> statistics: <span class="kw">SELECT</span> max/min/avg/sum/abs(cname) <span class="kw">FROM</span> tname; 
<span class="kw">SELECT</span> c <span class="kw">FROM</span> t T1 <span class="kw">WHERE</span> <span class="kw">NOT</span> <span class="kw">EXISTS</span> (<span class="kw">SELECT</span> * <span class="kw">FROM</span> t T2 <span class="kw">WHERE</span> T2.val&gt;T1.val);
<span class="kw">SELECT</span> c <span class="kw">FROM</span> t <span class="kw">WHERE</span> c &gt;= <span class="kw">ALL</span> (<span class="kw">SELECT</span> c <span class="kw">FROM</span> t); 
<span class="kw">SELECT</span> c <span class="kw">FROM</span> t <span class="kw">WHERE</span> <span class="kw">NOT</span> c &lt;  <span class="kw">ANY</span> (<span class="kw">SELECT</span> c <span class="kw">FROM</span> t); 
<span class="kw">SELECT</span> <span class="fu">round</span>(col,#digits) … 
<span class="kw">sort</span> (default=ASC): <span class="kw">SELECT</span> * <span class="kw">FROM</span> tname <span class="kw">ORDER</span> <span class="kw">BY</span> fieldname <span class="kw">DESC</span>;
<span class="kw">select</span> distinct: <span class="kw">SELECT</span> <span class="kw">DISTINCT</span> c <span class="kw">FROM</span> t; <span class="kw">SELECT</span> c <span class="kw">FROM</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> c;
<span class="fu">count</span> distinct: <span class="kw">SELECT</span> <span class="fu">count</span>(<span class="kw">DISTINCT</span> cname) <span class="kw">FROM</span> tname;
<span class="fu">count</span> non-NULL values: <span class="kw">SELECT</span> <span class="fu">count</span>(cname) <span class="kw">FROM</span> tname;
<span class="kw">sort</span> groups: <span class="kw">SELECT</span> c1, <span class="fu">sum</span>(c3) <span class="kw">FROM</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> c1 <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="fu">sum</span>(c3);
display <span class="kw">in</span> groups: <span class="kw">SELECT</span> c1, c2, <span class="fu">count</span>(col3) <span class="kw">FROM</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> c1, c2; 
filtering groups: <span class="kw">SELECT</span> c1, <span class="fu">count</span>(c3) <span class="kw">FROM</span> t <span class="kw">GROUP</span> <span class="kw">BY</span> c1 <span class="kw">HAVING</span> cndn;</code></pre>
  </div>
  <p>
   concatenate strings: really depends on platform
  </p>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="fu">CONCAT</span>(c1,c2) <span class="kw">FROM</span> t
<span class="kw">SELECT</span> c1+c2+’ ‘+c3 ..
<span class="kw">SELECT</span> c1 || ‘ ‘ || c2 <span class="kw">AS</span> email_address <span class="kw">FROM</span> … 
<span class="kw">SELECT</span> <span class="fu">LENGTH</span>(col)  … 
<span class="kw">SELECT</span> <span class="fu">MAX</span>(<span class="fu">LENGTH</span>(col)) … 
<span class="kw">change</span> case: <span class="kw">SELECT</span> <span class="fu">UPPER</span>(c1), <span class="fu">LOWER</span>(c2) … 
<span class="kw">SELECT</span> <span class="fu">SUBSTR</span>(col,#from,#inc) … 
<span class="dv">1</span>-based indexing
<span class="kw">SELECT</span> <span class="kw">REPLACE</span>(col,’from_string’,’to_string’) …
date: yyyy-mm-d
time: hh<span class="ch">:mm:ss</span>
datetime: yyyy-mm-dd hh<span class="ch">:mm:ss</span>
<span class="dt">DATE</span>(&lt;timestring&gt;,&lt;modifier&gt;,&lt;modifier&gt;, …)
timestring: “now”, “yyyy-mm-dd”
modifier: “-<span class="dv">7</span> days”, “+<span class="dv">2</span> months”
<span class="dt">DATE</span>(“datetime_string”) → yyyy-mm-dd
<span class="dt">TIME</span>(“datetime_string”) → hh<span class="ch">:mm:ss</span></code></pre>
  </div>
  <p>
   STRFTIME(“format_string”, ”datetime_string”,
   <modifier>
    ) “%d/%m/%Y”
   </modifier>
  </p>
  <h3>
   <a name="check-for-inclusion">
    Check for inclusion
   </a>
  </h3>
  <ul>
   <li>
    SELECT, FROM, CAST, RANK(), DENSE_RANK()
   </li>
   <li>
    WITH
   </li>
   <li>
    GROUP BY, HAVING, aggregate functions (SUM, MIN, MAX, AVG, COUNT)
   </li>
   <li>
    UPDATE
   </li>
   <li>
    OUTPUT
   </li>
   <li>
    MERGE
   </li>
   <li>
    remove duplicates
   </li>
   <li>
    subqueries (simple, correlated)
   </li>
   <li>
    EXCEPT
   </li>
   <li>
    DATE functions
   </li>
  </ul>
  <p>
   https://docs.microsoft.com/en-us/sql/t-sql/functions/aggregate-functions-transact-sql
  </p>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> c.CustomerID, c.TerritoryID, <span class="fu">COUNT</span>(o.SalesOrderid) <span class="kw">AS</span> [Total Orders],
    <span class="fu">DENSE_RANK</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> c.TerritoryID <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="fu">COUNT</span>(o.SalesOrderid)) <span class="kw">AS</span> [<span class="fu">Rank</span>]
<span class="kw">FROM</span> Sales.Customer c <span class="kw">LEFT</span> <span class="kw">OUTER</span> <span class="kw">JOIN</span> Sales.SalesOrderHeader o <span class="kw">ON</span> c.CustomerID = o.CustomerID
<span class="kw">WHERE</span> DATEPART(<span class="dt">year</span>, OrderDate) = <span class="dv">2007</span>
<span class="kw">GROUP</span> <span class="kw">BY</span> c.TerritoryID, c.CustomerID;</code></pre>
  </div>
  <p>
   Select product_id, name and selling start date for all products that started selling before 01/01/2006. Use the CAST function to display the date only. You need to work with the Production.Product table. The syntax for CAST is CAST(expression AS data_type), where expression is the column name we want to format and we can use DATE as data_type for this question to display just the date.
  </p>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> ProductID, Name, <span class="fu">CAST</span>(SellStartDate <span class="kw">AS</span> <span class="dt">DATE</span>) SellStartDate
<span class="kw">FROM</span> Production.Product
<span class="kw">WHERE</span> SellStartDate &lt; <span class="st">'01/01/2006'</span>;</code></pre>
  </div>
  <p>
   Select the product id, name, and list price for the product(s) that has the highest list price. You need to work with the Production.Product table. You’ll need to use a simple subquery to get the maximum list price and use it in the WHERE clause.
  </p>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> ProductID, Name, ListPrice
<span class="kw">FROM</span> Production.Product
<span class="kw">WHERE</span> ListPrice = (<span class="kw">SELECT</span> <span class="fu">MAX</span>(ListPrice) <span class="kw">FROM</span> Production.Product);</code></pre>
  </div>
  <p>
   Modify the following query to add a column that identifies the frequency of repeat customers and contains the following values based on the number of orders during 2007:
  </p>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> c.CustomerID, c.TerritoryID, <span class="fu">COUNT</span>(o.SalesOrderid) <span class="kw">AS</span> <span class="st">'Total Orders'</span>,
    <span class="kw">CASE</span>
        <span class="kw">WHEN</span> <span class="fu">COUNT</span>(o.SalesOrderid) = <span class="st">'0'</span>
            <span class="kw">THEN</span> <span class="st">'No Orders'</span>
        <span class="kw">WHEN</span> <span class="fu">COUNT</span>(o.SalesOrderid) = <span class="st">'1'</span>
            <span class="kw">THEN</span> <span class="st">'One Time'</span>
        <span class="kw">WHEN</span> <span class="fu">COUNT</span>(o.SalesOrderid) <span class="kw">BETWEEN</span> <span class="st">'2'</span> <span class="kw">AND</span> <span class="st">'5'</span>
            <span class="kw">THEN</span> <span class="st">'Regular'</span>
        <span class="kw">WHEN</span> <span class="fu">COUNT</span>(o.SalesOrderid) <span class="kw">BETWEEN</span> <span class="st">'6'</span> <span class="kw">AND</span> <span class="st">'12'</span>
            <span class="kw">THEN</span> <span class="st">'Often'</span>
        <span class="kw">ELSE</span> <span class="st">'Very Often'</span>
    <span class="kw">END</span> <span class="kw">AS</span> <span class="st">'Order Frequency'</span>
<span class="kw">FROM</span> Sales.Customer c <span class="kw">LEFT</span> <span class="kw">OUTER</span> <span class="kw">JOIN</span> Sales.SalesOrderHeader o <span class="kw">ON</span> c.CustomerID = o.CustomerID
<span class="kw">WHERE</span> <span class="dt">YEAR</span>(OrderDate) = <span class="dv">2007</span>
<span class="kw">GROUP</span> <span class="kw">BY</span> c.TerritoryID, c.CustomerID
<span class="kw">ORDER</span> <span class="kw">BY</span> <span class="st">'Order Frequency'</span> <span class="kw">DESC</span>;</code></pre>
  </div>
  <p>
   Write a SQL query to generate a list of customer ID's that have never placed an order before. Sort the list by CustomerID in the ascending order.
  </p>
  <p>
   Solution with JOIN:
  </p>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> CustomerID
<span class="kw">FROM</span> Sales.Customer c <span class="kw">LEFT</span> <span class="kw">OUTER</span> <span class="kw">JOIN</span> Sales.SalesOrderHeader h
<span class="kw">ON</span> c.CustomerID = h.CustomerID
<span class="kw">WHERE</span> h.CustomerID <span class="kw">IS</span> <span class="kw">NULL</span>
<span class="kw">ORDER</span> <span class="kw">BY</span> CustomerID <span class="kw">ASC</span>; </code></pre>
  </div>
  <p>
   Solution with subquery:
  </p>
  <div class="sourceCode">
   <pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> CustomerID
<span class="kw">FROM</span> Sales.Customer
<span class="kw">WHERE</span> CustomerID <span class="kw">NOT</span> <span class="kw">IN</span> 
    (<span class="kw">SELECT</span> CustomerID <span class="kw">FROM</span> Sales.SalesOrderHeader)
<span class="kw">ORDER</span> <span class="kw">BY</span> CustomerID <span class="kw">ASC</span>;</code></pre>
  </div>
  <p>
   T-SQL:
  </p>
  <ul>
   <li>
    Inclusive: SELECT … WHERE [date] BETWEEN ‘20120225’ AND ‘20120230’;
   </li>
   <li>
    Exclusive: SELECT … WHERE [date] &gt; 2012-02-25’ AND [date] &lt; ‘20120230’;
    <ul>
     <li>
      Note that dates are given as strings
     </li>
    </ul>
   </li>
   <li>
    Retrieve date, modify date &amp; alias: SELECT DATEADD(DAY, 7, OrderDate) AS "EstimatedDeliveryDate" FROM Sales.SalesOrderHeader WHERE MONTH(OrderDate) = 6 AND YEAR(OrderDate) = 2007;
   </li>
   <li>
    Numeric functions, aliasing, conditional selection. date functions: SELECT COUNT(*) AS 'HowManyMarchOrders', SUM(TotalDue) AS 'TotalDueForMarch', AVG(TotalDue) AS 'AvgOrderTotal',
    <ul>
     <li>
      SELECT COUNT(*) [HowManyMarchOrders] FROM ...
     </li>
    </ul>
   </li>
   <li>
    MIN(TotalDue) AS 'CheapestOrder', MAX(TotalDue) AS 'CostliestOrder' FROM Sales.SalesOrderHeader WHERE MONTH(OrderDate) = 5 AND YEAR(OrderDate) = 2008;
   </li>
   <li>
    SELECT CustomerID, COUNT(TotalDue) AS '#orders', SUM(TotalDue) AS '$orders' FROM Sales.SalesOrderHeader WHERE YEAR(OrderDate) = 2007 GROUP BY CustomerID HAVING COUNT(TotalDue) &gt; 1 - ORDER BY SUM(TotalDue) DESC;
   </li>
   <li>
    SELECT CONVERT(CHAR(20), DATEADD(DAY, 30, GETDATE()), 101) AS [30 Days From Today];
   </li>
   <li>
    SELECT DISTINCT SalesPersonID FROM Sales.SalesOrderHeader oh INNER JOIN Sales.SalesOrderDetail od ON oh.SalesOrderID = od.SalesOrderID WHERE ProductID = 777 ORDER BY SalesPersonID;
   </li>
  </ul>
  <h1>
   <a name="sources">
    SOURCES
   </a>
  </h1>
  <h2>
   <a name="references">
    References
   </a>
  </h2>
  <ul>
   <li>
    <a href="http://www.w3schools.com/sql/default.asp">
     w3schools SQL tutorial
    </a>
   </li>
   <li>
    <a href="http://weller.engl.uw.edu/mysql/">
     Weller’s SQL cheatsheet
    </a>
   </li>
   <li>
    <a href="https://github.com/treehouse/cheatsheets/blob/master/sql_basics/cheatsheet.md">
     Treehouse - SQL basics cheatsheet
    </a>
   </li>
   <li>
    <a href="https://github.com/treehouse/cheatsheets/blob/master/reporting_with_sql/cheatsheet.md">
     Treehouse - SQL reporting cheatsheet
    </a>
   </li>
   <li>
    <a href="https://github.com/treehouse/cheatsheets/blob/master/modifying_data_with_sql/cheatsheet.md">
     Treehouse - SQL to modify data cheatsheet
    </a>
   </li>
   <li>
    <a href="https://www.codecademy.com/articles/sql-commands">
     Codecademy - SQL Glossary
    </a>
   </li>
  </ul>
  <h2>
   <a name="archive">
    Archive
   </a>
  </h2>
  <ul>
   <li>
    <a href="https://academy.vertabelo.com/course/sql-queries">
     SQL queries
    </a>
   </li>
   <li>
    <a href="https://academy.vertabelo.com/course/operating-on-data-in-sql">
     Operating on data in SQL
    </a>
   </li>
   <li>
    <a href="https://academy.vertabelo.com/course/creating-tables-in-sql">
     Creating tables
    </a>
   </li>
   <li>
    <a href="http://www.sqlstyle.guide/">
     SQL Style Guide
    </a>
   </li>
   <li>
    <a href="https://teamtreehouse.com/library/reporting-with-sql">
     Treehouse - Reporting with SQL
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/SQL/SelfPaced/about">
     SQL
    </a>
   </li>
  </ul>
  <h2>
   <a name="inbox">
    Inbox
   </a>
  </h2>
  <ul>
   <li>
    <a href="http://www.kdnuggets.com/2016/06/seven-steps-mastering-sql-data-science.html">
     7 steps to mastering SQL
    </a>
   </li>
   <li>
    <a href="https://www.codecademy.com/learn/sql-table-transformation">
     Table Transformations
    </a>
   </li>
   <li>
    <a href="http://www.afterhoursprogramming.com/tutorial/SQL/SQL-Quiz/">
     SQL Quiz
    </a>
   </li>
   <li>
    <a href="http://sql.learncodethehardway.org/book/">
     Learn SQL the Hard Way
    </a>
   </li>
  </ul>
 </body>
</html>
