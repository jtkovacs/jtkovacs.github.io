<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <meta content="text/css" http-equiv="Content-Style-Type"/>
  <meta content="pandoc" name="generator"/>
  <title>
  </title>
  <link href="refs.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <p id="path">
   <a href="../../pkb.html">
    https://jtkovacs.github.io/pkb.html
   </a>
   &gt;
   <a href="https://jtkovacs.github.io/REFS/HTML/databases.html">
    https://jtkovacs.github.io/REFS/HTML/databases.html
   </a>
   &gt; 3493 words
  </p>
  <table class="TOC">
   <tr>
    <td>
     <ul>
      <li>
       <a href="#what-is-a-database?">
        What is a database?
       </a>
       <ul>
        <li>
         <a href="#history-of-databases">
          History of databases
         </a>
         <ul>
          <li>
           <a href="#ansi-sparc-architecture">
            ANSI-SPARC architecture
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#types-of-databases">
          Types of databases
         </a>
         <ul>
          <li>
           <a href="#the-relational-data-model">
            The relational data model
           </a>
           <ul>
            <li>
             <a href="#normalization">
              Normalization
             </a>
            </li>
            <li>
             <a href="#relationships-between-entities">
              Relationships between entities
             </a>
             <ul>
              <li>
               <a href="#associative-entities">
                Associative entities
               </a>
              </li>
              <li>
               <a href="#superclasses-and-subclasses">
                Superclasses and subclasses
               </a>
              </li>
             </ul>
            </li>
            <li>
             <a href="#types-of-attributes-">
              Types of attributes
             </a>
            </li>
            <li>
             <a href="#data-integrity-in-the-relational-model">
              Data integrity in the relational model
             </a>
             <ul>
              <li>
               <a href="#entity-integrity">
                Entity integrity
               </a>
              </li>
              <li>
               <a href="#domain-integrity">
                Domain integrity
               </a>
              </li>
              <li>
               <a href="#referential-integrity">
                Referential integrity
               </a>
              </li>
             </ul>
            </li>
           </ul>
          </li>
          <li>
           <a href="#nosql-databases">
            NoSQL databases
           </a>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#database-design">
        Database design
       </a>
       <ul>
        <li>
         <a href="#groundwork">
          Groundwork
         </a>
        </li>
        <li>
         <a href="#conceptual-design">
          Conceptual design
         </a>
         <ul>
          <li>
           <a href="#top-down-vs.-bottom-up-design">
            Top-down vs. bottom-up design
           </a>
           <ul>
            <li>
             <a href="#bottom-up-design-through-normalization">
              Bottom-up design through normalization
             </a>
            </li>
            <li>
             <a href="#top-down-design-with-erds">
              Top-down design with ERDs
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <a href="#logical-design">
          Logical design
         </a>
        </li>
        <li>
         <a href="#physical-design-&amp;-construction">
          Physical design &amp; construction
         </a>
         <ul>
          <li>
           <a href="#indexing-&amp;-performance">
            Indexing &amp; performance
           </a>
          </li>
         </ul>
        </li>
        <li>
         <a href="#rollout-&amp;-support">
          Rollout &amp; support
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#database-administration">
        Database administration
       </a>
       <ul>
        <li>
         <a href="#data-and-log-files">
          Data and log files
         </a>
        </li>
        <li>
         <a href="#transaction-management">
          Transaction management
         </a>
        </li>
        <li>
         <a href="#security">
          Security
         </a>
         <ul>
          <li>
           <a href="#authentication">
            Authentication
           </a>
          </li>
          <li>
           <a href="#backup">
            Backup
           </a>
          </li>
          <li>
           <a href="#encryption">
            Encryption
           </a>
           <ul>
            <li>
             <a href="#digital-signatures">
              Digital signatures
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
       </ul>
      </li>
      <li>
       <a href="#sources">
        Sources
       </a>
       <ul>
        <li>
         <a href="#references">
          References
         </a>
        </li>
        <li>
         <a href="#read">
          Read
         </a>
        </li>
        <li>
         <a href="#unread">
          Unread
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </td>
   </tr>
  </table>
  <h1>
   <a name="what-is-a-database?">
    What is a database?
   </a>
  </h1>
  <p>
   A
   <strong>
    database
   </strong>
   is a either (1) collection of data that's structured according to a
   <strong>
    data model
   </strong>
   (usually relational, as
   <a href="#the-relational-data-model">
    discussed below;
   </a>
   see
   <a href="information-architecture.html#information-structures">
    notes on information structures
   </a>
   for other major data models); or (2) this structured data plus a database management system (DBMS).
  </p>
  <p>
   A
   <a href="DBMS.html">
    DBMS
   </a>
   is either a
   <strong>
    database engine
   </strong>
   for interacting with the database plus a
   <strong>
    database frontend
   </strong>
   for user interaction, per definition (1) above; or these two things plus a database, per definition (2) above. A DMBS may be desktop-based (Access, FileMaker Pro) or server-based (SQL Server, Oracle, DB2, MySQL, PostgreSQL). See
   <a href="DBMS.html#core-functionality">
    notes on typical DBMS functionality.
   </a>
  </p>
  <p>
   A
   <strong>
    database system
   </strong>
   is a database/DBMS plus database applications (any applications that source from or feed data to the database). This term denotes only the technical environment of a database; the full
   <strong>
    database environment
   </strong>
   encompasses hardware, software, data, procedures, and people.
  </p>
  <h2>
   <a name="history-of-databases">
    History of databases
   </a>
  </h2>
  <p>
   The first computerized information systems (IBM, c. 1950) imitated
   <strong>
    hierarchical
   </strong>
   paper filing systems. The more semantically powerful
   <strong>
    graph
   </strong>
   AKA network data model followed shortly thereafter (1960s, also IBM). In early systems, file and data formats were specific to an application or language; applications were specific to a department. This arrangement led to
  </p>
  <ul>
   <li>
    <strong>
     <em>
      redundancy:
     </em>
    </strong>
    the same data collected ($$) and stored ($$) by multiple departments;
   </li>
   <li>
    <strong>
     <em>
      inconsistency:
     </em>
    </strong>
    redundant data that
    <em>
     should be the same
    </em>
    is not updated consistently;
   </li>
   <li>
    <strong>
     <em>
      inaccessibility:
     </em>
    </strong>
    software developers were needed to write queries and integrate data across applications; no ad hoc queries or data processing.
   </li>
  </ul>
  <p>
   Hierarchies and graphs were superseded by Edgar Codd's
   <strong>
    relational
   </strong>
   data model, proven in the 1970s and implemented in the 1980s. A relational database addresses the aforementioned problems because it is
   <strong>
    <em>
     centralized
    </em>
   </strong>
   (reducing redundancy, improving consistency, enabling data integration) and
   <strong>
    <em>
     abstracted
    </em>
   </strong>
   (available as a black box to interface with many different applications; offering an accessible language for ad hoc queries). It also:
  </p>
  <ul>
   <li>
    Scales to terabytes with excellent performance for processing transactions
   </li>
   <li>
    Is platform-independent due to ANSI standards, allowing transfer of code across different products
   </li>
   <li>
    Is comparatively cheap to purchase and maintain, and widely available
   </li>
   <li>
    Provides a
    <a href="SQL.html">
     programming/query language
    </a>
    that is easy to learn and execute, expediting data retrieval
   </li>
   <li>
    Minimizes data redundancy, conserving storage and safeguarding data quality (although some redundancy is still required to establish relationships)
   </li>
   <li>
    Can capture complex relationships (important for enforcing business rules)
   </li>
   <li>
    <a href="#data-integrity-in-the-relational-model">
     Preserves data integrity
    </a>
   </li>
  </ul>
  <p>
   <strong>
    Object
   </strong>
   databases introduced features like encapsulation and polymorphism c. 1990, but never became popular or standardized. With the advent of Big Data,
   <a href="#NoSQL-databases">
    NoSQL databases
   </a>
   (an umbrella term for non-relational database with SQL-like interface) have become popular because they beat relational DBs at quick search; however, relational databases are still better at maintaining data integrity (via transaction management with ACID properties).
  </p>
  <h3>
   <a name="ansi-sparc-architecture">
    ANSI-SPARC architecture
   </a>
  </h3>
  <p>
   This is one way of thinking about database abstraction/separation, which, in general, makes the database easier to change and maintain by providing
   <strong>
    data independence:
   </strong>
  </p>
  <ul>
   <li>
    External views for different users (i.e., subsets and derivations of the data) are described by subschemas. Views are
    <strong>
     logically independent
    </strong>
    from the conceptual level.
   </li>
   <li>
    The structure of the entire database---all entities, attributes, relationships, and constraints---is described by a conceptual schema. This conceptual layer is
    <strong>
     physically independent
    </strong>
    from implementation details.
   </li>
   <li>
    Implementation details, including storage allocation, compression, and encryption, are described by an internal schema.
   </li>
  </ul>
  <p>
   Then, the DBMS creates mappings (also called intensions; a realization of a schema is called the extension or state of the database) between schemas.
  </p>
  <h2>
   <a name="types-of-databases">
    Types of databases
   </a>
  </h2>
  <h3>
   <a name="the-relational-data-model">
    The relational data model
   </a>
  </h3>
  <p>
   In a relational database, the data model is of
   <strong>
    tables
   </strong>
   AKA relations. Tables have
   <strong>
    rows
   </strong>
   (AKA tuples, records) and
   <strong>
    columns
   </strong>
   (AKA attributes, fields). Order is insignificant.
  </p>
  <h4>
   <a name="normalization">
    Normalization
   </a>
  </h4>
  <p>
   Done to avoid transitive dependencies:
  </p>
  <ul>
   <li>
    https://stackoverflow.com/questions/9950367/what-is-wrong-with-a-transitive-dependency
   </li>
   <li>
    https://www.thoughtco.com/transitive-dependency-1019760
   </li>
  </ul>
  <p>
   Levels of normalization: http://searchsqlserver.techtarget.com/definition/normalization:
  </p>
  <ul>
   <li>
    “First normal form (1NF). This is the "basic" level of database normalization, and it generally corresponds to the definition of any database, namely:
    <ul>
     <li>
      It contains two-dimensional tables with rows and columns.
     </li>
     <li>
      Each column corresponds to a sub-object or an attribute of the object represented by the entire table.
     </li>
     <li>
      Each row represents a unique instance of that sub-object or attribute and must be different in some way from any other row (that is, no duplicate rows are possible).
     </li>
     <li>
      All entries in any column must be of the same kind. For example, in the column labeled "Customer," only customer names or numbers are permitted.
     </li>
    </ul>
   </li>
   <li>
    Second normal form (2NF). At this level of normalization, each column in a table that is not a determiner of the contents of another column must itself be a function of the other columns in the table. For example, in a table with three columns containing the customer ID, the product sold and the price of the product when sold, the price would be a function of the customer ID (entitled to a discount) and the specific product.
   </li>
   <li>
    Third normal form (3NF). At the second normal form, modifications are still possible because a change to one row in a table may affect data that refers to this information from another table. For example, using the customer table just cited, removing a row describing a customer purchase (because of a return, perhaps) will also remove the fact that the product has a certain price. In the third normal form, these tables would be divided into two tables so that product pricing would be tracked separately.”
   </li>
  </ul>
  <h4>
   <a name="relationships-between-entities">
    Relationships between entities
   </a>
  </h4>
  <ul>
   <li>
    http://www2.cs.uregina.ca/~bernatja/crowsfoot.html
   </li>
   <li>
    Relationships between entities have participation: mandatory/optional
   </li>
   <li>
    Relationships between entities have cardinalities AKA modalities: one-to-one, one-to-many, many-to-many
   </li>
   <li>
    “Many-to-many” relationships are “resolved” with an “associative entity” that has a combined primary key (PK), both of which are foreign keys (FK)
   </li>
   <li>
    A relationship is identifying if the PK of a parent entity appears in the PK of a child entity; it’s denoted with a solid line, while nonidentifying relationships are denoted with dashed lines
   </li>
  </ul>
  <h5>
   <a name="associative-entities">
    Associative entities
   </a>
  </h5>
  <p>
   When two entities are related in many-to-many fashion, an associative entity must be created to resolve the relationship. For example, consider a taxi company that owns cars; employs drivers; randomly assigns each driver a car for their shift; and wants to maintain a record for liability purposes. Entities CAR and DRIVER have a many-to-many relationship, since a driver will be assigned to multiple cars over the course of their employment. To capture the necessary data, SHIFTS is created as an associative entity with attributes driver ID, car ID, and shift date.
  </p>
  <h5>
   <a name="superclasses-and-subclasses">
    Superclasses and subclasses
   </a>
  </h5>
  <p>
   Entities may be specified superclasses and subclasses; this provides more semantic meaning to an ER model, makes the ER model more readable, and (depending on implementation) can reduce the number of NULLs in the database. There are several ways to implement super- and subclasses:
  </p>
  <ul>
   <li>
    Subclass contains superclass PK along with its own unique attributes;
   </li>
   <li>
    Subclass relations contain all superclass attributes along with its own unique attributes;
   </li>
   <li>
    One relation contains all super- and subclass attributes.
   </li>
  </ul>
  <h4>
   <a name="types-of-attributes">
    Types of attributes
   </a>
  </h4>
  <p>
   http://tinman.cs.gsu.edu/~raj/4340/sp12/er.html http://databasemanagement.wikia.com/wiki/E/R_Model:_Type_of_Attributes
  </p>
  <p>
   An attribute is composite if its value can be decomposed. For example, an entity CAT may have an attribute OWNER NAME; this composite attribute could be decomposed into two atomic/simple attributes (OWNER FIRST NAME, OWNER LAST NAME).
  </p>
  <p>
   An attribute is multi-valued/set-valued if, for a single entity, the attribute could/should store multiple values. For example, a PERSON entity may have a LANGUAGES SPOKEN attribute that must contain multiple values to accommodate multilingual people.
  </p>
  <p>
   An attribute is derived if its value can be calculated from (an)other attribute(s) in the database. For example, the value of the attribute TRIP DURATION could be derived from the attributes DEPARTURE DATE and RETURN DATE.
  </p>
  <p>
   Determinant: Attribute(s) whose value determines the value of a second (set of) attribute(s)
  </p>
  <p>
   An attribute may be a
   <strong>
    key
   </strong>
   or identity value. Kinds of keys:
  </p>
  <ul>
   <li>
    Surrogate Key: Artificial (non-intelligent) column added to entity for the sole purpose of performing Primary Key duties (oftentimes an INTEGER)
   </li>
   <li>
    Candidate Key: Column(s) that can uniquely identify rows in an entity
   </li>
  </ul>
  <p>
   Identity values must/How to pick a key. Which of the following are guidelines for an Entity Identifier (aka 'Primary Key')?
  </p>
  <ul>
   <li>
    INTEGER is most-often the best data type choice
   </li>
   <li>
    Will not change in value
   </li>
   <li>
    Will not be null
   </li>
   <li>
    Narrow field
   </li>
  </ul>
  <h4>
   <a name="data-integrity-in-the-relational-model">
    Data integrity in the relational model
   </a>
  </h4>
  <p>
   Domain integrity: column values should fall within a given domain, enforced by column data type Entity integrity: enforced by primary key Referential integrity: enforced by keys (PK-FK pair)
  </p>
  <h5>
   <a name="entity-integrity">
    Entity integrity
   </a>
  </h5>
  <p>
   rows are unique (they need a key).
  </p>
  <h5>
   <a name="domain-integrity">
    Domain integrity
   </a>
  </h5>
  <p>
   columns store single type of data; column names are unique. Columns have data types and domains, which can be a restricted list of values.
  </p>
  <h5>
   <a name="referential-integrity">
    Referential integrity
   </a>
  </h5>
  <p>
   Referential Integrity Constraint: Constraint that limits the values in an FK to those that already exist in the PK of the corresponding entity
  </p>
  <p>
   One table’s primary key may be used in another table as a foreign key, establishing a relationship between the two tables; referential integrity means that the key is consistent across tables. Specifically, when a row is added to the latter table, its FK value should come from the former table’s PK or it should be NULL.
  </p>
  <h3>
   <a name="nosql-databases">
    NoSQL databases
   </a>
  </h3>
  <p>
   NoSQL databases use a non-relational data model ...
  </p>
  <ul>
   <li>
    <strong>
     Key-value model,
    </strong>
    e.g. Dynamo, Riak, Basho:
    <em>
     [Key|Value|Timestamp].
    </em>
    Provides easy and fast storage for simple data.
   </li>
   <li>
    <strong>
     Columnar model,
    </strong>
    e.g. Google’s Bigtable, Apache’s HBase (part of Hadoop):
    <em>
     [Row Key|Value|Timestamp|Column Family|Column Name]
    </em>
    Good for retaining relationships (since columns can be grouped into families).
   </li>
   <li>
    Document: MongoDB, JSON, XML; good for storing complex hierarchical relationships
   </li>
   <li>
    Graph/triple store: Neo4j, PoolParty; good for capturing a web of relationships
   </li>
  </ul>
  <p>
   ... and ...
  </p>
  <p>
   ... to store Big Data ...
  </p>
  <ul>
   <li>
    large
    <strong>
     volume
    </strong>
    (petabytes rather than terabytes)
   </li>
   <li>
    wide
    <strong>
     variety
    </strong>
    (structured and unstructured)
   </li>
   <li>
    <p>
     high
     <strong>
      velocity
     </strong>
    </p>
   </li>
   <li>
    Distributed storage and processing (rather than client/server architecture)
   </li>
   <li>
    Memory cache
   </li>
   <li>
    Open source &amp; less costly hardware
   </li>
   <li>
    Batch (Google Map Reduce) or interactive or stream (Apache Tez Framework, Apache Spark, Facebook Presto) processing
   </li>
   <li>
    Typically both SQL-like and proprietary interfaces
    <ul>
     <li>
      NoSQL databases with SQL-like interfaces: Presto, Hive QL, Pig, Cassandra Query Language (CQL), Cosmos/Scope
     </li>
    </ul>
   </li>
  </ul>
  <p>
   Achieve greater speed by
  </p>
  <ul>
   <li>
    using append rather than updating records
   </li>
   <li>
    denormalizing data upon input
   </li>
  </ul>
  <p>
   NoSQL databases with analytics integration: Hive, Amazon’s Redshift, Facebook’s Presto, Airbnb’s Airpal
  </p>
  <h1>
   <a name="database-design">
    Database design
   </a>
  </h1>
  <p>
   Note that databases are often developed in parallel with the applications that will use them. Also, DB development may use CASE (computer-aided software engineering) tools that help with standardization, integration, consistency, and automation. For databases, CASE tools may provide forward engineering (generating database-creating code based on ERD) and reverse engineering (generating ERD from existing database; efficient way of producing documentation).
  </p>
  <p>
   A good design process prevents repetition; reduces errors (by limiting data entry through use of IDs, and imposing constraints); permits multiple analyses (by replacing multipart fields with atomic ones); avoids data conflicts (by reserving calculation to the analysis phase, rather than storing results); and ensures complete information (by requiring it during input). Best practices for DB design:
  </p>
  <ul>
   <li>
    Clearly identify scope of database
   </li>
   <li>
    Follow a database design methodology (SDLC, agile)
   </li>
   <li>
    Use a professional data modeling tool
   </li>
   <li>
    Use a source control system
   </li>
  </ul>
  <p>
   Connolly and Begg (2015) outline the following database development process AKA database system lifecycle:
  </p>
  <ul>
   <li>
    Gather business requirements (interviews, existing data, documents) → Mission &amp; objectives →
   </li>
   <li>
    Conceptual design: identify entities and attributes →
    <ul>
     <li>
      Top-down: entities, then attributes
     </li>
     <li>
      Bottom-up: attributes, then entities
     </li>
    </ul>
   </li>
   <li>
    Logical design: choose data model (probably relational) →
   </li>
   <li>
    Physical design: platform-specific details, e.g. indices →
   </li>
   <li>
    Implementation → Testing → Rollout.
   </li>
  </ul>
  <p>
   OR:
  </p>
  <ul>
   <li>
    Groundwork
   </li>
   <li>
    In the
    <strong>
     conceptual design stage,
    </strong>
    a database designer analyzes the business processes, documents, workflows, etc. that will be replaced or supported by the database. The goal is to understand thoroughly the business context of the database and to identify the entities (objects) and attributes (characteristics) it must contain.
   </li>
   <li>
    In the
    <strong>
     logical design stage,
    </strong>
    the entities and attributes are expressed in terms of the chosen data model (often relational). The goal is to express the data in a structured way that avoids data anomalies.
   </li>
   <li>
    Finally, in the
    <strong>
     physical design phase,
    </strong>
    the database designer produces software-specific instructions for implementing the database. The goal is to provide all the information necessary to build a database that takes advantage of features (like indexes) from the chosen platform.
   </li>
   <li>
    Implementation
   </li>
   <li>
    Rollout
   </li>
   <li>
    Maintenance
   </li>
  </ul>
  <h2>
   <a name="groundwork">
    Groundwork
   </a>
  </h2>
  <ul>
   <li>
    <strong>
     Conduct cost-benefit analysis for proposed database
    </strong>
   </li>
   <li>
    <strong>
     Requirements analysis
    </strong>
    :
    <ul>
     <li>
      Write a mission statement and objectives;
     </li>
     <li>
      Analyze current data inputs and outputs;
     </li>
     <li>
      Within the scope of the objectives, identify key actors;
     </li>
     <li>
      Interview actors to understand tasks that actors execute.
     </li>
    </ul>
   </li>
  </ul>
  <p>
   Explain what is meant by 'business rules' and provide an example.
  </p>
  <p>
   Business rules are database design constraints that arise from the business processes being modeled, not from requirements imposed by the relational data model (or other data model). Business rules affect the design of the database, including how entities are related; what attributes are collected; and what values are permitted or required for specific attributes. As an example, consider a database that stores donor and donations data for a nonprofit. Some business rules in this case might be that donors can make multiple donations, multiple donors can be associated with the same donation, and individual donation amounts must be over $10.
  </p>
  <h2>
   <a name="conceptual-design">
    Conceptual design
   </a>
  </h2>
  <ul>
   <li>
    <strong>
     Create conceptual design
    </strong>
    :
    <ul>
     <li>
      Group fields into tables a logical way;
     </li>
     <li>
      Identify relationships verbally, and/or visualize in UML;
     </li>
     <li>
      Identify cardinality (max#) and optionality (min#) associated with each relationship;
     </li>
     <li>
      Identify entity subtypes/subclasses;
     </li>
     <li>
      Create lookup tables;
     </li>
     <li>
      Identify primary keys (may be “natural”, i.e. present in the data, or “synthetic/surrogate”, for DB use alone; may be “concatenated/composite”.
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Normalize your data model
    </strong>
    (see
    <a href="#design-by-decomposition">
     Design by decomposition
    </a>
    )
    <ul>
     <li>
      1NF: all fields only include a single piece of data;
     </li>
     <li>
      2NF: all fields in the PK are required to determine the non-key fields, i.e., data not dependent on primary key is moved to another table;
     </li>
     <li>
      3NF: all the non-key fields are independent from other non-key fields, i.e., don’t store calculable data in the database (conduct calculations in SQL).
     </li>
    </ul>
   </li>
  </ul>
  <h3>
   <a name="top-down-vs.-bottom-up-design">
    Top-down vs. bottom-up design
   </a>
  </h3>
  <p>
   In the conceptual design stage of database development, there are two competing approaches: top-down and bottom-up. The top-down approach begins with identifying entities and relationships in the domain to be modeled, then filling in attributes. Entity relationship diagrams are often used. The bottom-up approach begins with identifying attributes, then grouping and normalizing them until entities and relationships emerge. Connolly and Begg (2015) suggest that a bottom-up approach is manageable only for smaller databases. For a larger, more complex database, a top-down approach may be necessary so that the database designer doesn’t get overwhelmed by numerous attributes.
  </p>
  <h4>
   <a name="bottom-up-design-through-normalization">
    Bottom-up design through normalization
   </a>
  </h4>
  <p>
   In the real world, we usually normalize only up to the 3rd Normal Form: TRUE
  </p>
  <p>
   Design by decomposition avoids redundancy and its consequences (update &amp; deletion anomalies). First, specify “mega” relations and dependencies to capture real-world constraints on the data; then, decompose into better (i.e., normalized) relations.
  </p>
  <p>
   <strong>
    Functional dependency (FD)
   </strong>
   ,
   <code>
    A→B
   </code>
   : The same A is always linked with the same B, although the reverse is not necessarily true. In predicate logic, a FD exists if, for
   <code>
    ∀ t,u ∈ R, t.A = u.A ⇒ t.B = u.B
   </code>
   . This generalizes to multiple attributes:
   <code>
    A1, A2, …, An → B1, B2, …, Bm.
   </code>
   FDs are used in DB compression and query optimization.
  </p>
  <ul>
   <li>
    trivial FD:
    <code>
     A→B &amp; B⊆A
    </code>
   </li>
   <li>
    nontrivial FD:
    <code>
     A→B &amp; B⊈A
    </code>
   </li>
   <li>
    completely nontrivial FD:
    <code>
     A→B &amp; A∩B=∅
    </code>
   </li>
   <li>
    transitive property:
    <code>
     A→B &amp; B→C ⇒ A→C
    </code>
   </li>
   <li>
    the
    <strong>
     closure
    </strong>
    of A, {A}*, is all attributes functionally determined by A
   </li>
   <li>
    <strong>
     keys
    </strong>
    are attributes whose closure encompasses all attributes in a relation
   </li>
   <li>
    <code>
     S2
    </code>
    , a set of FDs, follows from
    <code>
     S1
    </code>
    if every relation satisfying
    <code>
     S1
    </code>
    also satisfies
    <code>
     S2
    </code>
   </li>
   <li>
    <code>
     S2
    </code>
    , set of FDs, is equivalent to
    <code>
     S1
    </code>
    if exactly the same FDs follow from
    <code>
     S1
    </code>
    and
    <code>
     S2
    </code>
   </li>
  </ul>
  <p>
   Describe what Transitive Dependency is and give an example.
  </p>
  <p>
   If a functional dependency exists between X and Y, and a functional dependency exists between Y and Z, then a transitive dependency exists between X and Z. Transitive dependencies create problems in relational databases so they are typically removed during normalization. As an example, consider a table (perhaps in a bookstore database) with three attributes: ISBN, TITLE, AUTHOR, PHONE NUMBER. ISBN is the primary key; TITLE and AUTHOR are functionally dependent on it; but PHONE NUMBER is functionally dependent on AUTHOR, not on ISBN. Therefore a transitive dependency exists between PHONE NUMBER and ISBN.
  </p>
  <p>
   <a href="http://stackoverflow.com/questions/2718420/candidate-keys-from-functional-dependencies">
    <strong>
     Boyce Codd normal form
    </strong>
    (BCNF)
   </a>
   is when, for all FDs
   <code>
    A→B
   </code>
   , A is the key. To achieve BCNF, find FDs and keys for R
   <sub>
    i
   </sub>
   ; pick any R
   <sub>
    i
   </sub>
   with
   <code>
    A→B
   </code>
   violating BCNF; decompose into R
   <sub>
    1
   </sub>
   (A,B) and R
   <sub>
    2
   </sub>
   (A, rest); repeat.
  </p>
  <p>
   <strong>
    <a href="http://infolab.stanford.edu/~ullman/fcdb/aut07/slides/mvds.pdf">
     Multivalued dependency
    </a>
   </strong>
   (MVD),
   <code>
    A↠B
   </code>
   : A multivalued dependency exists if all tuples share their A attributes; tuple v shares B attributes with t, and its remaining attributes with u; tuple w shares A attributes with u, and its remaining attributes with t. In predicate logic:
   <code>
    if ∀ t,u∈R | t.A = u.A then ∃ v∈R | v.A=t.A and v.B=t.B and v.rest=u.rest.
   </code>
   Furthermore,
   <code>
    ∃ w∈R | w.A=t.A and w.B=u.B and w.rest=t.rest
   </code>
   .
  </p>
  <ul>
   <li>
    trivial MVD:
    <code>
     A↠B &amp; B⊆A
    </code>
    or
    <code>
     A∪B ={ all attributes}
    </code>
    ; e.g.
    <code>
     AB↠B
    </code>
   </li>
   <li>
    if
    <code>
     A→B
    </code>
    , then also
    <code>
     A↠B
    </code>
   </li>
   <li>
    intersection rule:
    <code>
     A↠B &amp; A↠C ⇒ A↠B⋂C
    </code>
   </li>
   <li>
    transitive rule:
    <code>
     A↠B &amp; B↠C ⇒ A↠C-B
    </code>
   </li>
   <li>
    a relation A is
    <strong>
     decomposed
    </strong>
    into B and C if the union of B and C’s attributes contains all of A’s attributes and
    <code>
     B⋈C = A
    </code>
    (the lossless join property).
   </li>
  </ul>
  <p>
   <strong>
    Fourth normal form
   </strong>
   (4NF) is more restrictive than BCNF. Its whole point is to separate independent information (i.e., not functionally dependent information) to achieve efficiency: B+C rather than B*C tuples. A relation is in 4NF if, for each nontrivial MVD
   <code>
    A↠B
   </code>
   , A is the key. To test for 4NF, look at each pair of tuples
   <code>
    t,u
   </code>
   that match on A, and create the additional tuples
   <code>
    v,w
   </code>
   : are they both already in the relation? If not, MVD is not satisfied. To achieve 4NF, find FDs, MVDs and keys for R
   <sub>
    i
   </sub>
   ; pick any R
   <sub>
    i
   </sub>
   with nontrivial
   <code>
    A↠B
   </code>
   violating 4NF (3) decompose into R
   <sub>
    1
   </sub>
   (A,B) and R
   <sub>
    2
   </sub>
   (A,rest); repeat.
  </p>
  <h4>
   <a name="top-down-design-with-erds">
    Top-down design with ERDs
   </a>
  </h4>
  <p>
   A top-down design approach creates an entity relationship diagram (ERD), starting with entities and associations then adding in attributes. ERDs can be done in
   <a href="modeling.html#erds-for-databases">
    ER or UML notation;
   </a>
   MS Visio offers both.
  </p>
  <h2>
   <a name="logical-design">
    Logical design
   </a>
  </h2>
  <ul>
   <li>
    <strong>
     Create logical design (rules and constraints)
    </strong>
    :
    <ul>
     <li>
      Proceed table by table, field by field;
     </li>
     <li>
      Choose naming conventions: avoid special characters and reserved words for your DBMS;
     </li>
     <li>
      Choose data types;
      <ul>
       <li>
        Store numbers as text if you don’t need to manipulate them mathematically, e.g. phone numbers
       </li>
      </ul>
     </li>
     <li>
      Resolve many-to-many relationships by adding a junction table with the two tables’ PKs as its composite PK;
     </li>
     <li>
      Apply integrity constraints:
      <ul>
       <li>
        With a lookup table;
       </li>
       <li>
        With a referential integrity constraint to prevent orphaned records;
       </li>
       <li>
        Through a check constraint.
       </li>
      </ul>
     </li>
     <li>
      Denote required fields;
     </li>
    </ul>
   </li>
  </ul>
  <h2>
   <a name="physical-design-&amp;-construction">
    Physical design &amp; construction
   </a>
  </h2>
  <p>
   Physical design depends on DBMS-specific features; see
   <a href="DBMS.html">
    notes on DBMS software.
   </a>
  </p>
  <h3>
   <a name="indexing-&amp;-performance">
    Indexing &amp; performance
   </a>
  </h3>
  <p>
   Build indexes for the most commonly searched fields (PK indexed by default; indexing reduces write speed).
  </p>
  <ul>
   <li>
    <a class="uri" href="http://use-the-index-luke.com/sql/table-of-contents">
     http://use-the-index-luke.com/sql/table-of-contents
    </a>
   </li>
   <li>
    <a class="uri" href="https://www.simple-talk.com/sql/performance/14-sql-server-indexing-questions-you-were-too-shy-to-ask/">
     https://www.simple-talk.com/sql/performance/14-sql-server-indexing-questions-you-were-too-shy-to-ask/
    </a>
   </li>
  </ul>
  <p>
   Select all accurate statements about indexes.
  </p>
  <ul>
   <li>
    Indexes could improve query performance but slow down database content update: T
   </li>
   <li>
    Clustered indexes determine the physical storage of the related data: T
   </li>
   <li>
    There can be more than one non-clustered index on a table: T
   </li>
   <li>
    There can be more than one clustered index on a table: FALSE
   </li>
   <li>
    Columnstore index used to improve performance of read-only tables
   </li>
  </ul>
  <h2>
   <a name="rollout-&amp;-support">
    Rollout &amp; support
   </a>
  </h2>
  <h1>
   <a name="database-administration">
    Database administration
   </a>
  </h1>
  <h2>
   <a name="data-and-log-files">
    Data and log files
   </a>
  </h2>
  <h2>
   <a name="transaction-management">
    Transaction management
   </a>
  </h2>
  <p>
   ACID
  </p>
  <h2>
   <a name="security">
    Security
   </a>
  </h2>
  <h3>
   <a name="authentication">
    Authentication
   </a>
  </h3>
  <h3>
   <a name="backup">
    Backup
   </a>
  </h3>
  <h3>
   <a name="encryption">
    Encryption
   </a>
  </h3>
  <h4>
   <a name="digital-signatures">
    Digital signatures
   </a>
  </h4>
  <p>
   Digital signatures are based on Public Key techniques; are different for each use; are commonly used for online transactions
  </p>
  <h1>
   <a name="sources">
    Sources
   </a>
  </h1>
  <p>
   Connolly, T. &amp; Begg, C. (2015).
   <em>
    Database systems: A practical approach to design, implementation, and management
   </em>
   (6th ed.). New York City, NY: Pearson Education.
  </p>
  <h2>
   <a name="references">
    References
   </a>
  </h2>
  <h2>
   <a name="read">
    Read
   </a>
  </h2>
  <ul>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/RDB/SelfPaced/about">
     Intro. to Relational Databases
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/RA/SelfPaced/about">
     Relational Algebra
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/RD/SelfPaced/about">
     Relational Design Theory
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/UML/SelfPaced/about">
     Unified Modeling Language
    </a>
   </li>
   <li>
    <a href="http://www.lynda.com/Access-tutorials/Relational-Database-Fundamentals/145932-2.html">
     Relational Database Fundamentals
    </a>
   </li>
   <li>
    <a href="http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html">
     ORM is an offensive anti-pattern
    </a>
   </li>
   <li>
    <a href="http://www.lynda.com/Access-tutorials/Access-2016-Essential-Training/367064-2.html">
     Access 2016
    </a>
   </li>
  </ul>
  <h2>
   <a name="unread">
    Unread
   </a>
  </h2>
  <ul>
   <li>
    <a href="https://www.codecademy.com/articles/sql-rdbms">
     Overview of SQL RDBMS
    </a>
   </li>
   <li>
    <a href="http://coding-geek.com/how-databases-work/">
     How does a relational database work?
    </a>
   </li>
   <li>
    <a href="https://www.lynda.com/Access-tutorials/Migrating-Access-Databases-SQL-Server/397389-2.html">
     Migrating Access Databases to SQL Server
    </a>
   </li>
   <li>
    <a href="http://www.lynda.com/SQL-Server-tutorials/Database-Fundamentals-Core-Concepts/385693-2.html">
     Core Concepts for SQL Server
    </a>
   </li>
   <li>
    <a href="http://www.lynda.com/SQL-Server-tutorials/Database-Fundamentals-Storage/385694-2.html">
     Storage in SQL Server
    </a>
   </li>
   <li>
    <a href="http://www.lynda.com/SQL-Server-tutorials/Database-Fundamentals-Creating-Manipulating-Data/385697-2.html">
     Data Manipulation in SQL Server
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/Indexes/SelfPaced/about">
     Indexes &amp; Transactions
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/Constraints/SelfPaced/about">
     Constraints &amp; Triggers
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/Views/SelfPaced/about">
     Views &amp; Authorization
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/OLAP/SelfPaced/about">
     OLAP
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/Recursion/SelfPaced/about">
     Recursion
    </a>
   </li>
   <li>
    <a href="http://databases.about.com/od/specificproducts/a/Database-Dependency.htm">
     Database dependency
    </a>
   </li>
   <li>
    <a href="https://www.codeschool.com/courses/the-magical-marvels-of-mongodb">
     CodeSchool - NoSQL with MongoDB
    </a>
   </li>
   <li>
    <a href="https://neo4j.com/developer/graph-db-vs-rdbms/">
     From relational to graph databases
    </a>
   </li>
   <li>
    <a href="https://en.wikipedia.org/wiki/Blockchain_(database)">
     Blockchain
    </a>
   </li>
   <li>
    <a href="https://news.ycombinator.com/item?id=9436847">
     Is Git a blockchain?
    </a>
   </li>
   <li>
    <a href="http://dataconomy.com/sql-vs-nosql-need-know/">
     SQL vs NoSQL
    </a>
   </li>
   <li>
    <a href="http://faculty.washington.edu/blabob/bob/eBooks/Beyond%20Relational%20(WP%20MarkLogic%202015).pdf">
     Beyond Relational
    </a>
   </li>
   <li>
    <a href="http://faculty.washington.edu/blabob/bob/eBooks/Why%20NoSQL%20(WP%20IBM).PDF">
     Why NoSQL
    </a>
   </li>
   <li>
    <a href="http://www.kdnuggets.com/2016/07/seven-steps-understanding-nosql-databases.html">
     7 steps to understanding NoSQL databases
    </a>
   </li>
   <li>
    <a href="http://apigee.com/about/blog/technology/nosql-noproblem-mapping-your-sql-thinking-nosql">
     Mapping your SQL thinking to NoSQL
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/XML/SelfPaced/about">
     XML data
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/XPath/SelfPaced/about">
     XPath &amp; XQuery
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/XSLT/SelfPaced/about">
     XSLT
    </a>
   </li>
   <li>
    <a href="https://bigdatauniversity.com/courses/sql-access-on-hadoop-big-sql-v4/">
     BigSQL on Hadoop
    </a>
   </li>
   <li>
    <a href="http://faculty.washington.edu/blabob/bob/eBooks/Enterprise%20NoSQL%20for%20Dummies%20(eBook).pdf">
     Enterprise NoSQL for Dummies
    </a>
   </li>
   <li>
    <a href="http://graphdatabases.com/">
     Graph Databases
    </a>
   </li>
  </ul>
 </body>
</html>
