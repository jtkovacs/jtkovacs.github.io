<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <meta content="text/css" http-equiv="Content-Style-Type"/>
  <meta content="pandoc" name="generator"/>
  <title>
   jtkovacs.github.io | databases
  </title>
  <link href="../assets/styles/main.css" rel="stylesheet" type="text/css"/>
  <link href="../assets/styles/refs.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <p class="path">
   <a href="../pkb.html">
    pkb contents
   </a>
   &gt; databases | just under 4975 words | updated 05/27/2017
  </p>
  <div class="TOC">
   <ul>
    <li>
     1.
     <a href="#what-is-a-database">
      What is a database?
     </a>
     <ul>
      <li>
       1.1.
       <a href="#the-database-system-lifecycle">
        The database system lifecycle
       </a>
      </li>
      <li>
       1.2.
       <a href="#history-of-databases">
        History of databases
       </a>
       <ul>
        <li>
         1.2.1.
         <a href="#ansi-sparc-architecture">
          ANSI-SPARC architecture
         </a>
        </li>
       </ul>
      </li>
      <li>
       1.3.
       <a href="#types-of-databases">
        Types of databases
       </a>
       <ul>
        <li>
         1.3.1.
         <a href="#the-relational-data-model">
          The relational data model
         </a>
         <ul>
          <li>
           1.3.1.1.
           <a href="#relationships-between-entities">
            Relationships between entities
           </a>
           <ul>
            <li>
             1.3.1.1.1.
             <a href="#associative-entities">
              Associative entities
             </a>
            </li>
            <li>
             1.3.1.1.2.
             <a href="#superclasses-and-subclasses">
              Superclasses and subclasses
             </a>
            </li>
           </ul>
          </li>
          <li>
           1.3.1.2.
           <a href="#types-of-attributes">
            Types of attributes
           </a>
          </li>
          <li>
           1.3.1.3.
           <a href="#relationships-between-attributes">
            Relationships between attributes
           </a>
           <ul>
            <li>
             1.3.1.3.1.
             <a href="#functional-dependencies-and-keys">
              Functional dependencies and keys
             </a>
            </li>
            <li>
             1.3.1.3.2.
             <a href="#transitive-dependencies">
              Transitive dependencies
             </a>
            </li>
            <li>
             1.3.1.3.3.
             <a href="#multivalued-dependencies">
              Multivalued dependencies
             </a>
            </li>
           </ul>
          </li>
          <li>
           1.3.1.4.
           <a href="#integrity">
            Integrity
           </a>
           <ul>
            <li>
             1.3.1.4.1.
             <a href="#normalization">
              Normalization
             </a>
            </li>
            <li>
             1.3.1.4.2.
             <a href="#why-not-normalize">
              Why not normalize?
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         1.3.2.
         <a href="#nosql-databases">
          NoSQL databases
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     2.
     <a href="#database-development">
      Database development
     </a>
     <ul>
      <li>
       2.1.
       <a href="#business-requirements">
        Business requirements
       </a>
      </li>
      <li>
       2.2.
       <a href="#design-phases">
        Design phases
       </a>
       <ul>
        <li>
         2.2.1.
         <a href="#conceptual-design">
          Conceptual design
         </a>
        </li>
        <li>
         2.2.2.
         <a href="#logical-design">
          Logical design
         </a>
        </li>
        <li>
         2.2.3.
         <a href="#physical-design">
          Physical design
         </a>
         <ul>
          <li>
           2.2.3.1.
           <a href="#database-architectures">
            Database architectures
           </a>
          </li>
          <li>
           2.2.3.2.
           <a href="#files-and-filegroups">
            Files and filegroups
           </a>
           <ul>
            <li>
             2.2.3.2.1.
             <a href="#storage-size">
              Storage size
             </a>
            </li>
           </ul>
          </li>
          <li>
           2.2.3.3.
           <a href="#indexing-and-performance">
            Indexing and performance
           </a>
           <ul>
            <li>
             2.2.3.3.1.
             <a href="#why-to-index">
              Why to index
             </a>
            </li>
            <li>
             2.2.3.3.2.
             <a href="#what-to-index">
              What to index
             </a>
            </li>
            <li>
             2.2.3.3.3.
             <a href="#how-different-types-of-indexes-work">
              How different types of indexes work
             </a>
            </li>
            <li>
             2.2.3.3.4.
             <a href="#fragmentation">
              Fragmentation
             </a>
            </li>
           </ul>
          </li>
         </ul>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     3.
     <a href="#database-administration">
      Database administration
     </a>
     <ul>
      <li>
       3.1.
       <a href="#transaction-management">
        Transaction management
       </a>
      </li>
      <li>
       3.2.
       <a href="#security">
        Security
       </a>
       <ul>
        <li>
         3.2.1.
         <a href="#security-threats">
          Security threats
         </a>
        </li>
        <li>
         3.2.2.
         <a href="#security-solutions">
          Security solutions
         </a>
         <ul>
          <li>
           3.2.2.1.
           <a href="#encryption">
            Encryption
           </a>
           <ul>
            <li>
             3.2.2.1.1.
             <a href="#tde">
              TDE
             </a>
            </li>
           </ul>
          </li>
          <li>
           3.2.2.2.
           <a href="#access-control">
            Access control
           </a>
           <ul>
            <li>
             3.2.2.2.1.
             <a href="#ownership-chaining">
              Ownership chaining
             </a>
            </li>
            <li>
             3.2.2.2.2.
             <a href="#contained-database">
              Contained database
             </a>
            </li>
           </ul>
          </li>
          <li>
           3.2.2.3.
           <a href="#preventing-sql-injections">
            Preventing SQL injections
           </a>
          </li>
         </ul>
        </li>
        <li>
         3.2.3.
         <a href="#security-audits">
          Security audits
         </a>
        </li>
       </ul>
      </li>
      <li>
       3.3.
       <a href="#backup">
        Backup
       </a>
      </li>
     </ul>
    </li>
    <li>
     4.
     <a href="#sources">
      Sources
     </a>
     <ul>
      <li>
       4.1.
       <a href="#cited">
        Cited
       </a>
      </li>
      <li>
       4.2.
       <a href="#references">
        References
       </a>
      </li>
      <li>
       4.3.
       <a href="#read">
        Read
       </a>
      </li>
      <li>
       4.4.
       <a href="#unread">
        Unread
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </div>
  <p>
   <em>
    These notes are heavily influenced by Dr. Simon Wu-Ping Wang's slides as well as Connolly and Begg (2015).
   </em>
  </p>
  <h1 id="what-is-a-database">
   <a>
    1. What is a database?
   </a>
  </h1>
  <p>
   A
   <strong>
    database
   </strong>
   is a either (1) collection of data that's structured according to a
   <strong>
    data model
   </strong>
   (usually relational, as
   <a href="#the-relational-data-model">
    discussed below;
   </a>
   see
   <a href="information-architecture.html#information-structures">
    notes on information structures
   </a>
   for other major data models); or (2) this structured data plus a database management system (DBMS).
  </p>
  <p>
   A
   <a href="DBMS.html">
    DBMS
   </a>
   is either a
   <strong>
    database engine
   </strong>
   for interacting with the database plus a
   <strong>
    database frontend
   </strong>
   for user interaction, per definition (1) above; or these two things plus a database, per definition (2) above. A DMBS may be desktop-based (Access, FileMaker Pro) or server-based (SQL Server, Oracle, DB2, MySQL, PostgreSQL). Typical DBMS offer:
  </p>
  <ul>
   <li>
    A convenient language with two data sublanguages:
    <ul>
     <li>
      Data definition language
      <strong>
       (DDL)
      </strong>
      expresses the schema;
     </li>
     <li>
      Data manipulation language
      <strong>
       (DML),
      </strong>
      <ul>
       <li>
        enables
        <strong>
         CRUD operations
        </strong>
        (create, read, update, delete);
       </li>
       <li>
        includes the capacity to query/retrieve/read the data and is therefore often called a query language, though this is technically incorrect (because partial);
       </li>
       <li>
        may be procedural or, as with SQL, nonprocedural/declarative;
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li>
    Access to database metadata (includes schema) through the system catalog AKA data directory, data dictionary;
   </li>
   <li>
    Support for concurrent access (data sharing);
   </li>
   <li>
    Enforcement of access authorization (security);
   </li>
   <li>
    Enforcement of constraints on data input (integrity);
   </li>
   <li>
    Backup and recovery;
   </li>
   <li>
    Views that are customized to the needs of specific audiences.
   </li>
  </ul>
  <p>
   Finally, a
   <strong>
    database system
   </strong>
   is a database/DBMS plus database applications (any applications that source from or feed data to the database). This term denotes only the technical environment of a database; the full
   <strong>
    database environment
   </strong>
   encompasses hardware, software, data, procedures, and people.
  </p>
  <h2 id="the-database-system-lifecycle">
   <a>
    1.1. The database system lifecycle
   </a>
  </h2>
  <table>
   <tr>
    <th colspan="2">
     Requirements Analysis
    </th>
   </tr>
   <tr>
    <th rowspan="3">
     Design
    </th>
    <td>
     Conceptual
    </td>
   </tr>
   <tr>
    <td>
     Logical
    </td>
   </tr>
   <tr>
    <td>
     Physical
    </td>
   </tr>
   <tr>
    <th rowspan="2">
     Development
    </th>
    <td>
     Implementation
    </td>
   </tr>
   <tr>
    <td>
     Testing
    </td>
   </tr>
   <tr>
    <th rowspan="2">
     Administration
    </th>
    <td>
     Rollout
    </td>
   </tr>
   <tr>
    <td>
     Support
    </td>
   </tr>
  </table>
  <h2 id="history-of-databases">
   <a>
    1.2. History of databases
   </a>
  </h2>
  <p>
   The first computerized information systems (IBM, c. 1950) imitated
   <strong>
    hierarchical
   </strong>
   paper filing systems. The more semantically powerful
   <strong>
    graph
   </strong>
   AKA network data model followed shortly thereafter (1960s, also IBM). In early systems, file and data formats were specific to an application or language; applications were specific to a department. This arrangement led to
  </p>
  <ul>
   <li>
    <strong>
     <em>
      redundancy:
     </em>
    </strong>
    the same data collected ($$) and stored ($$) by multiple departments;
   </li>
   <li>
    <strong>
     <em>
      inconsistency:
     </em>
    </strong>
    redundant data that
    <em>
     should be the same
    </em>
    is not updated consistently;
   </li>
   <li>
    <strong>
     <em>
      inaccessibility:
     </em>
    </strong>
    software developers were needed to write queries and integrate data across applications; no ad hoc queries or data processing.
   </li>
  </ul>
  <p>
   Hierarchies and graphs were superseded by Edgar Codd's
   <strong>
    relational
   </strong>
   data model, proven in the 1970s and implemented in the 1980s. A relational database addresses the aforementioned problems because it is
   <strong>
    <em>
     centralized
    </em>
   </strong>
   (reducing redundancy, improving consistency, enabling data integration) and
   <strong>
    <em>
     abstracted
    </em>
   </strong>
   (available as a black box to interface with many different applications; offering an accessible language for ad hoc queries). It also:
  </p>
  <ul>
   <li>
    Scales to terabytes with excellent performance for processing transactions
   </li>
   <li>
    Is platform-independent due to ANSI standards, allowing transfer of code across different products
   </li>
   <li>
    Is comparatively cheap to purchase and maintain, and widely available
   </li>
   <li>
    Provides a
    <a href="SQL.html">
     programming/query language
    </a>
    that is easy to learn and execute, expediting data retrieval
   </li>
   <li>
    Minimizes data redundancy, conserving storage and safeguarding data quality (although some redundancy is still required to establish relationships)
   </li>
   <li>
    Can capture complex relationships (important for enforcing business rules)
   </li>
   <li>
    <a href="#integrity">
     Preserves data integrity
    </a>
   </li>
  </ul>
  <p>
   <strong>
    Object
   </strong>
   databases introduced features like encapsulation and polymorphism c. 1990, but never became popular or standardized. With the advent of Big Data,
   <a href="#NoSQL-databases">
    NoSQL databases
   </a>
   (an umbrella term for non-relational database with SQL-like interface) have become popular because they beat relational DBs at quick search; however, relational databases are still better at maintaining data integrity (via transaction management with ACID properties).
  </p>
  <h3 id="ansi-sparc-architecture">
   <a>
    1.2.1. ANSI-SPARC architecture
   </a>
  </h3>
  <p>
   This is one way of thinking about database abstraction/separation, which, in general, makes the database easier to change and maintain by providing
   <strong>
    data independence:
   </strong>
  </p>
  <ul>
   <li>
    External views for different users (i.e., subsets and derivations of the data) are described by subschemas. Views are
    <strong>
     logically independent
    </strong>
    from the conceptual level.
   </li>
   <li>
    The structure of the entire database---all entities, attributes, relationships, and constraints---is described by a conceptual schema. This conceptual layer is
    <strong>
     physically independent
    </strong>
    from implementation details.
   </li>
   <li>
    Implementation details, including storage allocation, compression, and encryption, are described by an internal schema.
   </li>
  </ul>
  <p>
   Then, the DBMS creates mappings (also called intensions; a realization of a schema is called the extension or state of the database) between schemas.
  </p>
  <h2 id="types-of-databases">
   <a>
    1.3. Types of databases
   </a>
  </h2>
  <h3 id="the-relational-data-model">
   <a>
    1.3.1. The relational data model
   </a>
  </h3>
  <p>
   In a relational database, the data model is of
   <strong>
    tables
   </strong>
   AKA relations, which can be clustered tables or heaps
   <a href="#indexing-and-performance">
    depending on their indexing.
   </a>
   Tables have
   <strong>
    rows
   </strong>
   (AKA tuples, records) and
   <strong>
    columns
   </strong>
   (AKA attributes, fields). The order of rows and columns is insignificant (unless an
   <a href="#indexing-and-performance">
    index
   </a>
   is created).
  </p>
  <p>
   Representing reality in terms of entities, attributes and relationships occurs during the
   <a href="#conceptual-design">
    conceptual design phase
   </a>
   of database development. Per Ullman (2006),
   <strong>
    many different relational schemas could be used to model any given reality;
   </strong>
   the best designs will suit the underlying business processes and be
   <a href="#normalization">
    in a normal form.
   </a>
  </p>
  <h4 id="relationships-between-entities">
   <a>
    1.3.1.1. Relationships between entities
   </a>
  </h4>
  <p>
   The relationship between two entites has several characteristics. The
   <strong>
    participation
   </strong>
   of a relationship is mandatory or optional; the
   <strong>
    cardinality
   </strong>
   AKA modality of a relationships may be one-to-one, one-to-many, or many-to-many; see
   <a href="modeling.html#erds-for-databases">
    ERDs
   </a>
   for notation. A relationship is
   <strong>
    identifying
   </strong>
   if the PK of a parent entity appears in the PK of a child entity, denoted with a solid line; nonidentifying relationships are denoted with dashed lines.
  </p>
  <h5 id="associative-entities">
   <a>
    1.3.1.1.1. Associative entities
   </a>
  </h5>
  <p>
   Many-to-many relationships must be resolved with an associative entity (AKA junction table) that has a combined primary key (PK), both of which are foreign keys (FK)---though there are
   <a href="http://codebetter.com/jeremymiller/2007/02/01/composite-keys-are-evil/">
    arguments for
   </a>
   and
   <a href="https://stackoverflow.com/questions/37784634/primary-key-of-associative-entity">
    against
   </a>
   creating a synthetic key for an associative entity. For example, consider a taxi company that owns cars; employs drivers; randomly assigns each driver a car for their shift; and wants to maintain a record for liability purposes. Entities CAR and DRIVER have a many-to-many relationship, since a driver will be assigned to multiple cars over the course of their employment and a car will likewise be driven by many different drivers. To capture the necessary data, SHIFTS is created as an associative entity with attributes driver ID, car ID, and shift date.
  </p>
  <h5 id="superclasses-and-subclasses">
   <a>
    1.3.1.1.2. Superclasses and subclasses
   </a>
  </h5>
  <p>
   Entities may be classified as superclasses and subclasses; this provides more semantic meaning to an ER model, makes the ER model more readable, and (depending on implementation) can reduce the number of NULLs in the database. There are several implementation options:
  </p>
  <ul>
   <li>
    Subclass entity contains superclass PK along with its own unique attributes;
   </li>
   <li>
    Subclass entity contains all superclass attributes along with its own unique attributes;
   </li>
   <li>
    The ERD includes a superclass and subclass(es) but they are implemented as a single table.
   </li>
  </ul>
  <h4 id="types-of-attributes">
   <a>
    1.3.1.2. Types of attributes
   </a>
  </h4>
  <p>
   Per Sunderraman (2012) and the Database Management Wikia (n.d.), an attribute is:
  </p>
  <ul>
   <li>
    <strong>
     Composite
    </strong>
    if it can be decomposed into
    <strong>
     atomic
    </strong>
    attributes (which, per first normal form, it should be).
   </li>
   <li>
    <strong>
     Derived
    </strong>
    if its value can be calculated from (an)other attribute(s) (which, per third normal form, it shouldn't be).
   </li>
   <li>
    <strong>
     Multi-valued
    </strong>
    AKA set-valued if, for a single entity, the attribute could/should store multiple values (one-to-many relationship); in this case, the multi-valued attribute should be moved to a new table and linked back to the main entity via the entity's primary key.
   </li>
  </ul>
  <h4 id="relationships-between-attributes">
   <a>
    1.3.1.3. Relationships between attributes
   </a>
  </h4>
  <p>
   Different sorts of relationships AKA dependencies exist between attributes; this is not a modeling decision, it is a feature of the real world. Dependencies are important for understanding
   <a href="#normalization">
    normalization;
   </a>
   normalization is a process of allocating attributes to entities to achieve a certain configuration of dependencies within each entity. Dependencies are also used (somehow?) in DB compression and query optimization.
  </p>
  <h5 id="functional-dependencies-and-keys">
   <a>
    1.3.1.3.1. Functional dependencies and keys
   </a>
  </h5>
  <p>
   A functional dependency
   <code>
    A → B
   </code>
   exists when the same A (for our purposes, an attribute value called the
   <strong>
    determinant)
   </strong>
   is linked to a single B (another attribute value, called the
   <strong>
    dependent).
   </strong>
   The reverse is not necessarily true. Note that this is like a mathematical function, where each x, a function input, must correspond to exactly one y, a function output, but a single value of y might correspond to multiple different values of x:
  </p>
  <table>
   <thead>
    <tr class="header">
     <th align="left">
      This is a Function
     </th>
     <th align="left">
      This is Not a Function
     </th>
    </tr>
   </thead>
   <tbody>
    <tr class="odd">
     <td align="left">
      <img src="illos/fcn.png"/>
     </td>
     <td align="left">
      <img src="illos/not-fcn.png"/>
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   Written in predicate logic with tuples denoted t and u, attributes denoted A and B, a functional dependency exists if, for
   <code>
    ∀ t,u ∈ R, t.A = u.A ⇒ t.B = u.B
   </code>
   ; this generalizes to multiple attributes, such that a determinant is best (i.e., worst) defined as (an) attribute(s) whose value(s) determine(s) the value(s) of a second (set of) attribute(s). There are a few special cases:
  </p>
  <ul>
   <li>
    Trivial:
    <code>
     A → B &amp; B ⊆ A
    </code>
   </li>
   <li>
    Nontrivial:
    <code>
     A → B &amp; B ⊈ A
    </code>
   </li>
   <li>
    Completely nontrivial:
    <code>
     A → B &amp; A ∩ B = ∅
    </code>
   </li>
   <li>
    Technically transitive dependencies are functional dependencies
   </li>
  </ul>
  <p>
   The set of attributes that are functionally dependent on a determinant is called the determinant's
   <strong>
    closure,
   </strong>
   <code>
    {A}*.
   </code>
   A closure can obviously be as small as a single attribute. Per displayName (2015), a determinant whose closure is the
   <em>
    entire table
   </em>
   is a
   <strong>
    candidate key
   </strong>
   AKA identity value; one candidate key is chosen as the table's sole
   <strong>
    primary key (PK).
   </strong>
   <a href="http://stackoverflow.com/questions/2718420/candidate-keys-from-functional-dependencie">
    This is an excellent demonstration of identifying (super) keys.
   </a>
  </p>
  <p>
   In general, keys may be
   <strong>
    natural,
   </strong>
   i.e. present in the data, or
   <strong>
    synthetic
   </strong>
   AKA surrogate, automatically generated by the database for internal use. Keys may also be
   <strong>
    composite
   </strong>
   AKA concatenated, meaning that several attributes taken together (a set) are a determinant whose closure is the entire table. For primary keys specifically, they are most often an integer (the narrowest suitable field); immutable; and mandatory.
  </p>
  <h5 id="transitive-dependencies">
   <a>
    1.3.1.3.2. Transitive dependencies
   </a>
  </h5>
  <p>
   If a functional dependency exists between X and Y, and a functional dependency exists between Y and Z, then a transitive dependency exists between X and Z:
   <code>
    A → B &amp; B → C ⇒ A → C.
   </code>
   As an example, consider a table (perhaps in a bookstore database) with three attributes: ISBN, TITLE, AUTHOR, PHONE NUMBER. ISBN is the primary key; TITLE and AUTHOR are functionally dependent on it; but PHONE NUMBER is functionally dependent on AUTHOR, not on ISBN. Therefore a transitive dependency exists between PHONE NUMBER and ISBN.
  </p>
  <h5 id="multivalued-dependencies">
   <a>
    1.3.1.3.3. Multivalued dependencies
   </a>
  </h5>
  <p>
   A multivalued dependency
   <code>
    A ↠ B
   </code>
   exists if all tuples share their A attributes; tuple v shares B attributes with t, and its remaining attributes with u; tuple w shares A attributes with u, and its remaining attributes with t. In predicate logic:
   <code>
    if ∀ t,u∈R | t.A = u.A then ∃ v∈R | v.A=t.A and v.B=t.B and v.rest=u.rest.
   </code>
   Furthermore,
   <code>
    ∃ w∈R | w.A=t.A and w.B=u.B and w.rest=t.rest
   </code>
   . MVDs matter for 4NF;
   <a href="http://infolab.stanford.edu/~ullman/fcdb/aut07/slides/mvds.pdf">
    examples and details here.
   </a>
  </p>
  <h4 id="integrity">
   <a>
    1.3.1.4. Integrity
   </a>
  </h4>
  <p>
   Data must have integrity to be useful and trustworthy. Data integrity
   <a href="wrangling.html#dirty-data-typologies">
    tends to erode,
   </a>
   and a database has mechanisms for maintaining it in its various forms:
  </p>
  <ul>
   <li>
    <strong>
     Entity integrity
    </strong>
    is the assurance that entities in the real world are represented in each applicable table of the database by a single record (row). The constraint that rows be unique is enforced through the primary key.
    <br/>
   </li>
   <li>
    <strong>
     Domain integrity
    </strong>
    is the assurance that attributes have meaningful (as in possible, if not necessarily accurate) values. This is enforced by column data types and custom domain restrictions.
   </li>
   <li>
    <strong>
     Referential integrity
    </strong>
    is the assurance that, once one-to-many or many-to-many relationships are separated into different tables, the data is still kept in sync despite updates and deletions. Specifically, when a row is added to the latter table, its FK value should come from the former table’s PK or it should be NULL.
   </li>
  </ul>
  <div class="figure">
   <img src="illos/integrity.png"/>
  </div>
  <p>
   Additionally, database designs are normalized to preserve integrity and minimize redundancy (by limiting storage costs).
  </p>
  <h5 id="normalization">
   <a>
    1.3.1.4.1. Normalization
   </a>
  </h5>
  <p>
   Normalization is a process of allocating attributes to entities to achieve a certain configuration of
   <a href="#relationships-between-attributes">
    dependencies
   </a>
   within each entity;
   <a href="http://www.bkent.net/Doc/simple5.htm">
    Bill Kent
   </a>
   does a good job talking about this in terms of which attributes provide "facts" about other attributes. There are five but actually maybe six levels of normalization, with third normal form the commonly accepted target. The first normal form is how Codd articulated his relational data model in the 1970s, with the other forms progressive refinements of the basic relational model:
  </p>
  <ul>
   <li>
    <strong>
     1NF:
    </strong>
    Rows are unique (i.e., there is a primary key for entity integrity) and columns have a datatype (for domain integrity); all attributes are atomic (enabling calculations).
   </li>
   <li>
    <strong>
     2NF:
    </strong>
    All columns in a table must be related via
    <a href="functional-dependencies-and-keys">
     FDs;
    </a>
    i.e., each column must be either (part of) the table's determinant (PK) or dependent on the table's determinant. This may require the creation of new entities to resolve one-to-many and many-to-many relationships through PK/FK pairs, minimizing redundancy.
   </li>
   <li>
    <strong>
     3NF:
    </strong>
    Remove
    <a href="#transitive-dependencies">
     TDs
    </a>
    and derived attributes, preventing modification anomalies (example below).
   </li>
   <li>
    <strong>
     BCNF:
    </strong>
    <a href="http://psoug.org/reference/normalization.html">
     Extreme version of 3NF
    </a>
    where, for all FDs
    <code>
     A → B,
    </code>
    A is the PK.
   </li>
   <li>
    <strong>
     4NF:
    </strong>
    Remove
    <a href="#multivalued-dependencies">
     MVDs,
    </a>
    somehow increasing efficiency because there are B+C vs. B*C tuples??
   </li>
   <li>
    <strong>
     5NF:
    </strong>
    ???
   </li>
  </ul>
  <p>
   This
   <a href="https://www.thoughtco.com/transitive-dependency-1019760">
    example from ThoughtCo
   </a>
   shows how normal forms prevent anomalies. In this case there are two FDs
   <code>
    (Book → Author, Author → Author_Nationality)
   </code>
   and one TD
   <code>
    (Book → Author_Nationality),
   </code>
   plus a violation of 1NF's atomic field requirement:
  </p>
  <table>
   <thead>
    <tr class="header">
     <th align="left">
      Author
     </th>
     <th align="left">
      Book
     </th>
     <th align="left">
      Author_Nationality
     </th>
    </tr>
   </thead>
   <tbody>
    <tr class="odd">
     <td align="left">
      Orson Scott Card
     </td>
     <td align="left">
      Ender's Game
     </td>
     <td align="left">
      United States
     </td>
    </tr>
    <tr class="even">
     <td align="left">
      Orson Scott Card
     </td>
     <td align="left">
      Children of the Mind
     </td>
     <td align="left">
      United States
     </td>
    </tr>
    <tr class="odd">
     <td align="left">
      Margaret Atwood
     </td>
     <td align="left">
      The Handmaid's Tale
     </td>
     <td align="left">
      Canada
     </td>
    </tr>
   </tbody>
  </table>
  <p>
   Note the redundancy---repeating pairs of (Orson Scott Card, United States), caused by the transitive dependency---and the liabilities it creates in the form of potential data loss and data corruption:
  </p>
  <ul>
   <li>
    If you deleted Card's two books, you would remove
    <em>
     him
    </em>
    as an entity from the database. This is a
    <strong>
     deletion anomaly.
    </strong>
   </li>
   <li>
    You must add an author to add a book, and vice versa; this is an
    <strong>
     insertion anomaly.
    </strong>
   </li>
   <li>
    If an attribute value changes, you'd need to find and update every occurrence to maintain database accuracy---but you might not, and instead have an
    <strong>
     update anomaly.
    </strong>
   </li>
  </ul>
  <p>
   3NF creates several tables instead:
  </p>
  <table>
   <thead>
    <tr class="header">
     <th align="left">
      AuthorID
     </th>
     <th align="left">
      Author_Firstname
     </th>
     <th align="left">
      Author_Lastname
     </th>
     <th align="left">
      Author_Nationality
     </th>
    </tr>
   </thead>
   <tbody>
    <tr class="odd">
     <td align="left">
      01
     </td>
     <td align="left">
      Orson Scott
     </td>
     <td align="left">
      Card
     </td>
     <td align="left">
      United States
     </td>
    </tr>
    <tr class="even">
     <td align="left">
      02
     </td>
     <td align="left">
      Margaret
     </td>
     <td align="left">
      Atwood
     </td>
     <td align="left">
      Canada
     </td>
    </tr>
   </tbody>
  </table>
  <table>
   <thead>
    <tr class="header">
     <th align="left">
      AuthorID
     </th>
     <th align="left">
      BookID
     </th>
    </tr>
   </thead>
   <tbody>
    <tr class="odd">
     <td align="left">
      01
     </td>
     <td align="left">
      001
     </td>
    </tr>
    <tr class="even">
     <td align="left">
      01
     </td>
     <td align="left">
      002
     </td>
    </tr>
    <tr class="odd">
     <td align="left">
      02
     </td>
     <td align="left">
      003
     </td>
    </tr>
   </tbody>
  </table>
  <table>
   <thead>
    <tr class="header">
     <th align="left">
      BookID
     </th>
     <th align="left">
      Book_Name
     </th>
    </tr>
   </thead>
   <tbody>
    <tr class="odd">
     <td align="left">
      001
     </td>
     <td align="left">
      Ender's Game
     </td>
    </tr>
    <tr class="even">
     <td align="left">
      002
     </td>
     <td align="left">
      Children of the Mind
     </td>
    </tr>
    <tr class="odd">
     <td align="left">
      003
     </td>
     <td align="left">
      The Handmaid's Tale
     </td>
    </tr>
   </tbody>
  </table>
  <h5 id="why-not-normalize">
   <a>
    1.3.1.4.2. Why not normalize?
   </a>
  </h5>
  <p>
   Per Chapple (2016):
  </p>
  <ul>
   <li>
    Normalization means more tables; more tables mean more
    <a href="SQL.html">
     JOINs;
    </a>
    JOINs are slow.
   </li>
   <li>
    Normalization is a complex, time-consuming process and developer time is valuable, so operate in the spirit of 'quick and dirty'.
   </li>
  </ul>
  <h3 id="nosql-databases">
   <a>
    1.3.2. NoSQL databases
   </a>
  </h3>
  <p>
   NoSQL databases use non-relational data models ...
  </p>
  <ul>
   <li>
    <strong>
     Key-value model,
    </strong>
    e.g. Dynamo, Riak, Basho:
    <em>
     [Key|Value|Timestamp].
    </em>
    Provides easy and fast storage for simple data.
   </li>
   <li>
    <strong>
     Columnar model,
    </strong>
    e.g. Google’s Bigtable, Apache’s HBase (part of Hadoop):
    <em>
     [Row Key|Value|Timestamp|Column Family|Column Name].
    </em>
    Good for retaining relationships (since columns can be grouped into families).
   </li>
   <li>
    <strong>
     Document model,
    </strong>
    e.g. MongoDB, JSON, XML. Good for storing complex hierarchical relationships.
   </li>
   <li>
    <strong>
     Graph/triple model,
    </strong>
    e.g. Neo4j. Good for capturing a web of relationships.
   </li>
  </ul>
  <p>
   ... plus some of these other features ...
  </p>
  <ul>
   <li>
    Open source &amp; less costly hardware
   </li>
   <li>
    Distributed storage and processing rather than client/server architecture
   </li>
   <li>
    Memory cache
   </li>
   <li>
    Batch processing (Google Map Reduce) or interactive AKA stream processing (Apache Tez Framework, Apache Spark, Facebook Presto)
   </li>
   <li>
    Proprietary and/or (for Presto, Hive QL, Pig, Cassandra Query Language (CQL), Cosmos/Scope) SQL-like interfaces
    <br/>
   </li>
   <li>
    Analytics integration (Hive, Amazon’s Redshift, Facebook’s Presto, Airbnb’s Airpal)
   </li>
  </ul>
  <p>
   ... to store Big Data ...
  </p>
  <ul>
   <li>
    large
    <strong>
     volume
    </strong>
    (petabytes rather than terabytes)
   </li>
   <li>
    wide
    <strong>
     variety
    </strong>
    (structured and unstructured)
   </li>
   <li>
    high
    <strong>
     velocity
    </strong>
   </li>
  </ul>
  <p>
   ... achieving greater speed by:
  </p>
  <ul>
   <li>
    appending rather than updating records, and
   </li>
   <li>
    denormalizing data upon input.
   </li>
  </ul>
  <h1 id="database-development">
   <a>
    2. Database development
   </a>
  </h1>
  <p>
   A good design process minimizes redundancy; reduces errors by automating or imposing constraints on data entry; permits multiple analyses by replacing multipart fields with atomic ones; avoids data conflicts by reserving calculation to the analysis phase, rather than storing results; and ensures complete information by requiring it during input.
   <strong>
    Best practices for DB design:
   </strong>
  </p>
  <ul>
   <li>
    Clearly identify scope of database
   </li>
   <li>
    Follow a database design methodology, e.g. SDLC, Agile
   </li>
   <li>
    Use a professional data modeling tool, e.g. MS Visio
   </li>
   <li>
    Use a source control system, e.g. GitHub
   </li>
  </ul>
  <p>
   Note that databases are often developed in parallel with the applications that will use them. Also, DB development may use CASE (computer-aided software engineering) tools that help with standardization, integration, consistency, and automation. For databases, CASE tools may provide forward engineering (generating database-creating code based on ERD) and reverse engineering (generating ERD from existing database; an efficient way of producing documentation).
  </p>
  <h2 id="business-requirements">
   <a>
    2.1. Business requirements
   </a>
  </h2>
  <ul>
   <li>
    Conduct a
    <strong>
     cost-benefit analysis
    </strong>
    for the proposed database;
   </li>
   <li>
    Write a
    <strong>
     mission statement and objectives;
    </strong>
   </li>
   <li>
    Gather and formulate
    <strong>
     business requirements
    </strong>
    by analyzing the business processes, documents, workflows, etc. that will be replaced or supported by the database:
    <ul>
     <li>
      Within the scope of the objectives, identify key
      <strong>
       actors;
      </strong>
     </li>
     <li>
      Interview actors to understand
      <strong>
       tasks
      </strong>
      that actors execute;
     </li>
     <li>
      Identify pertinent
      <strong>
       business rules,
      </strong>
      i.e., database design constraints that arise from the business processes being modeled, not from requirements of the data model.
     </li>
    </ul>
   </li>
  </ul>
  <h2 id="design-phases">
   <a>
    2.2. Design phases
   </a>
  </h2>
  <p>
   All stages of design are beholden to the underlying data model. Conceptual design is broader, mostly focused on grouping attributes into tables; logical design is more granular, mostly focused on properties and constraints of each attribute. Lastly, physical design is focused on specifying the database and its interfaces, etc. according to a particular DBMS.
  </p>
  <h3 id="conceptual-design">
   <a>
    2.2.1. Conceptual design
   </a>
  </h3>
  <p>
   In the conceptual design stage of database development, there are two competing approaches:
  </p>
  <ul>
   <li>
    The
    <strong>
     top-down approach
    </strong>
    (AKA design by decomposition) begins with identifying entities and relationships in the domain to be modeled, then filling in attributes. Entity relationship diagrams are often used. ERDs can be done in
    <a href="modeling.html#erds-for-databases">
     ER or UML notation;
    </a>
    MS Visio offers both.
   </li>
   <li>
    The
    <strong>
     bottom-up approach
    </strong>
    begins with identifying attributes, then grouping them until entities and relationships emerge. Connolly and Begg (2015) suggest that a bottom-up approach is manageable only for smaller databases. For a larger, more complex database, a top-down approach may be necessary so that the database designer doesn’t get overwhelmed by numerous attributes.
   </li>
  </ul>
  <p>
   Regardless, the end goal is a schema that is
   <a href="#normalization">
    normalized
   </a>
   to avoid anomalies.
  </p>
  <p>
   In addition to constructing tables via a top-down or bottom-up approach, a conceptual design should:
  </p>
  <ul>
   <li>
    Identify relationships verbally;
   </li>
   <li>
    Identify cardinality (max#) and optionality (min#) associated with each relationship;
   </li>
   <li>
    Identify entity subtypes/subclasses;
   </li>
   <li>
    Specify lookup tables;
   </li>
   <li>
    Identify
    <a href="#types-of-attributes">
     primary keys.
    </a>
   </li>
  </ul>
  <h3 id="logical-design">
   <a>
    2.2.2. Logical design
   </a>
  </h3>
  <p>
   Proceed table by table, field by field:
  </p>
  <ul>
   <li>
    Choose naming conventions (avoid special characters and reserved words for your DBMS);
   </li>
   <li>
    Choose data types, which vary by DBMS;
    <ul>
     <li>
      Store numbers as text if you don’t need to manipulate them mathematically, e.g. phone numbers
     </li>
    </ul>
   </li>
   <li>
    Resolve many-to-many relationships with
    <a href="#associative-entities">
     associative entities;
    </a>
   </li>
   <li>
    Apply
    <a href="#integrity">
     integrity constraints:
    </a>
    <ul>
     <li>
      With a lookup table;
     </li>
     <li>
      With a referential integrity constraint to prevent orphaned records;
     </li>
     <li>
      Through a check constraint.
     </li>
    </ul>
   </li>
   <li>
    Denote required fields.
   </li>
  </ul>
  <h3 id="physical-design">
   <a>
    2.2.3. Physical design
   </a>
  </h3>
  <p>
   The goal of the physical design stage is to provide all the information necessary to build a database that takes advantage of features from the chosen platform. Physical design depends on DBMS-specific features, so consult notes on specific DBMS software; this discussion is based on MS SQL Server.
  </p>
  <h4 id="database-architectures">
   <a>
    2.2.3.1. Database architectures
   </a>
  </h4>
  <div class="figure">
   <img alt="Source: Simon Wang" src="illos/db-arch1.png"/>
   <p class="caption">
    <strong>
     Source:
    </strong>
    Simon Wang
   </p>
  </div>
  <div class="figure">
   <img alt="Source: Simon Wang" src="illos/db-arch2.png"/>
   <p class="caption">
    <strong>
     Source:
    </strong>
    Simon Wang
   </p>
  </div>
  <div class="figure">
   <img alt="Source: Simon Wang" src="illos/db-arch3.png"/>
   <p class="caption">
    <strong>
     Source:
    </strong>
    Simon Wang
   </p>
  </div>
  <div class="figure">
   <img alt="Source: Simon Wang" src="illos/db-arch4.png"/>
   <p class="caption">
    <strong>
     Source:
    </strong>
    Simon Wang
   </p>
  </div>
  <h4 id="files-and-filegroups">
   <a>
    2.2.3.2. Files and filegroups
   </a>
  </h4>
  <p>
   A DBMS records
   <em>
    actions
   </em>
   in its
   <strong>
    log file
   </strong>
   (.LDF) and data (as pages; see
   <a href="#how-different-types-of-indexes-work">
    discussion on indexing
   </a>
   and
   <a href="">
    SQL Server files)
   </a>
   in its
   <strong>
    data file.
   </strong>
   During backup, the local log file is wiped but the data files are unchanged.
  </p>
  <p>
   MS SQL Server stores table data (rows) in uniformly-sized pages AKA blocks:
  </p>
  <div class="figure">
   <img src="illos/SQLDataPage.png"/>
  </div>
  <h5 id="storage-size">
   <a>
    2.2.3.2.1. Storage size
   </a>
  </h5>
  <p>
   If the main data file (.MDF) exceeds its initially allocated space, there are several options:
  </p>
  <ul>
   <li>
    Specify a new size limit
   </li>
   <li>
    Specify a growth rate
   </li>
   <li>
    Move the data file to a larger drive
   </li>
   <li>
    Create multiple data files (.NDF)
    <ul>
     <li>
      Create filegroups to manage multiple data files as one object
     </li>
    </ul>
   </li>
  </ul>
  <h4 id="indexing-and-performance">
   <a>
    2.2.3.3. Indexing and performance
   </a>
  </h4>
  <h5 id="why-to-index">
   <a>
    2.2.3.3.1. Why to index
   </a>
  </h5>
  <p>
   Various kinds of indexes are created to accelerate queries (SELECT rows from pages) at the expense of write speed (INSERT, UPDATE, and DELETE operations). Per Sheldon (2014), not
   <em>
    all
   </em>
   indexes improve performance for
   <em>
    all
   </em>
   queries; more complex queries that involve grouping and sorting can suffer from a clustered index.
  </p>
  <p>
   Because of this read/write tradeoff, indexes are most useful in
   <a href="information-systems.html#what-are-mis?">
    reporting databases versus transactional databases.
   </a>
   Alternatively, an index may be erased when loading a very large dataset into the database, then subsequently restored.
  </p>
  <h5 id="what-to-index">
   <a>
    2.2.3.3.2. What to index
   </a>
  </h5>
  <p>
   The PK is indexed by default, and commonly searched fields may be indexed as well. Many DBMS offer a
   <strong>
    query optimizer
   </strong>
   that identifies statistically when indexing would be beneficial. Often indexing a PK/FK pair will improve JOIN performance (and JOINs are very costly).
  </p>
  <h5 id="how-different-types-of-indexes-work">
   <a>
    2.2.3.3.3. How different types of indexes work
   </a>
  </h5>
  <p>
   A table is either a
   <strong>
    heap
   </strong>
   or, if it has a clustered index, a
   <strong>
    clustered table.
   </strong>
   A heap is simply unsorted data pages; the order of its contents (i.e., how its rows are allocated across data pages) will be determined initially by data entry and then by DBMS-initiated changes (for efficiency's sake). A
   <strong>
    clustered index,
   </strong>
   on the other hand, introduces sorting that is implemented at the level of pages through row offset arrays AKA slot arrays; see Sheffield (2012). For this reason, there can be only one clustered index per table (PK by default).
  </p>
  <p>
   To facilitate specific queries, both heaps and clustered tables may have multiple
   <strong>
    non-clustered indexes
   </strong>
   that provide alternate sort orders "very much like the index at the end of a book: it occupies its own space, it is highly redundant, and it refers to the actual information stored in a different place" (Winand, n.d.).
  </p>
  <ul>
   <li>
    When a subset of rows are indexed, this is called a
    <strong>
     filtered index.
    </strong>
   </li>
   <li>
    When multiple fields are included in a single non-clustered index, this is called a
    <strong>
     covering index
    </strong>
    because it could "cover" all the fields retrieved in a stored query.
   </li>
  </ul>
  <p>
   Just as heaps and clustered tables store their rows in data pages, non-clustered indexes store their
   <strong>
    leaf nodes
   </strong>
   in data pages. Via pointers,
   <a href="http://use-the-index-luke.com/sql/anatomy/the-leaf-nodes">
    leaves are doubly connected
   </a>
   to each other (to maintain sort order as rows are added and deleted) and also point to rows in the heap/clustered table (thereby making the index useful):
  </p>
  <div class="figure">
   <img src="illos/nonclustered-index.png"/>
  </div>
  <p>
   For heap pages, clustered indexes, and non-clustered indexes alike, a
   <strong>
    B-tree
   </strong>
   AKA balanced tree structure with
   <a href="http://use-the-index-luke.com/sql/anatomy/the-tree">
    root and intermediary nodes
   </a>
   is used to make page search more efficient:
  </p>
  <p>
   <img src="illos/B-tree.png" style="padding-top: 5px;" width="500px"/>
  </p>
  <p>
   Finally, while heaps, clustered indexes, and non-clustered indexes use a rowstore structure (Sheldon, 2013), a
   <strong>
    columnstore index
   </strong>
   (useful for read-heavy databases with star or snowflake schemas, i.e. BI warehouses) searches only relevant columns:
  </p>
  <div class="figure">
   <img src="illos/columnstore.png"/>
  </div>
  <h5 id="fragmentation">
   <a>
    2.2.3.3.4. Fragmentation
   </a>
  </h5>
  <p>
   Index fragmentation is inevitable, especially in OLTP environments:
  </p>
  <ul>
   <li>
    INSERT and UPDATE operations lead to page splits
    <strong>
     (logical fragmentation?)
    </strong>
   </li>
   <li>
    DELETE operations lead to partially-filled pages
    <strong>
     (internal fragmentation)
    </strong>
   </li>
   <li>
    Large rows
    <strong>
     (extent fragmentation?)
    </strong>
   </li>
  </ul>
  <p>
   Fragmentation can be detected with a DBMS tool, then repaired:
  </p>
  <ul>
   <li>
    Clustered indexes:
    <ul>
     <li>
      &lt;1000 pages long or &lt;5% fragmentation, do nothing
     </li>
     <li>
      5% &lt; logical fragmentation &lt; 30%:
      <strong>
       reorganize
      </strong>
     </li>
     <li>
      30% &lt; logical fragmentation:
      <strong>
       rebuild
      </strong>
     </li>
    </ul>
   </li>
   <li>
    Extent fragmentation of a heap table (non-indexed) can be reduced by creating then dropping a clustered index
   </li>
  </ul>
  <table style="width:42%;">
   <colgroup>
    <col width="22%">
    </col>
    <col width="6%">
    </col>
    <col width="12%">
    </col>
   </colgroup>
   <thead>
    <tr class="header">
     <th align="left">
      Characteristic
     </th>
     <th align="left">
      Reorganize
     </th>
     <th align="left">
      Rebuild
     </th>
    </tr>
   </thead>
   <tbody>
    <tr class="odd">
     <td align="left">
      Online or offline
     </td>
     <td align="left">
      Online
     </td>
     <td align="left">
      Offline as default; online as option
     </td>
    </tr>
    <tr class="even">
     <td align="left">
      Internal fragmentation
     </td>
     <td align="left">
      Yes
     </td>
     <td align="left">
      Yes
     </td>
    </tr>
    <tr class="odd">
     <td align="left">
      Logical fragmentation
     </td>
     <td align="left">
      Yes
     </td>
     <td align="left">
      Yes
     </td>
    </tr>
    <tr class="even">
     <td align="left">
      Transaction atomicity
     </td>
     <td align="left">
      Small discrete transactions
     </td>
     <td align="left">
      Single atomic transaction
     </td>
    </tr>
    <tr class="odd">
     <td align="left">
      Rebuild statistics automatically
     </td>
     <td align="left">
      No
     </td>
     <td align="left">
      Yes
     </td>
    </tr>
    <tr class="even">
     <td align="left">
      Parallel execution
     </td>
     <td align="left">
      No
     </td>
     <td align="left">
      Yes
     </td>
    </tr>
    <tr class="odd">
     <td align="left">
      Untangle indexes that are interleaved with the data file
     </td>
     <td align="left">
      No
     </td>
     <td align="left">
      Yes
     </td>
    </tr>
    <tr class="even">
     <td align="left">
      Transaction log space used
     </td>
     <td align="left">
      Less
     </td>
     <td align="left">
      More
     </td>
    </tr>
    <tr class="odd">
     <td align="left">
      Additional free space required in the data file
     </td>
     <td align="left">
      No
     </td>
     <td align="left">
      Yes
     </td>
    </tr>
   </tbody>
  </table>
  <h1 id="database-administration">
   <a>
    3. Database administration
   </a>
  </h1>
  <h2 id="transaction-management">
   <a>
    3.1. Transaction management
   </a>
  </h2>
  <ul>
   <li>
    ACID
   </li>
   <li>
    https://www.thoughtco.com/abandoning-acid-in-favor-of-base-1019674
   </li>
  </ul>
  <h2 id="security">
   <a>
    3.2. Security
   </a>
  </h2>
  <h3 id="security-threats">
   <a>
    3.2.1. Security threats
   </a>
  </h3>
  <p>
   Common security threats may be categorized by human vectors or by system targets:
  </p>
  <table class="bullets">
   <tr>
    <th>
     Users
    </th>
    <th>
     Developers
    </th>
    <th>
     Administrators
    </th>
   </tr>
   <tr>
    <td style="text-align: left;">
     <ul>
      <li>
       Use of person's means of access
      </li>
      <li>
       Inappropriate data sharing
      </li>
      <li>
       Inadequate training
      </li>
      <li>
       Blackmail
      </li>
      <li>
       Unwitting conduit for viruses or hacks
      </li>
     </ul>
    </td>
    <td style="text-align: left;">
     <ul>
      <li>
       Creation of trapdoor
      </li>
      <li>
       Staff shortages leading to bad code
      </li>
      <li>
       Lack of security training and procedures
      </li>
     </ul>
    </td>
    <td style="text-align: left; width=50px;">
     <ul>
      <li>
       Inadequate policies and procedures
      </li>
     </ul>
    </td>
   </tr>
  </table>
  <table class="bullets">
   <tr>
    <th>
     Hardware
    </th>
    <th>
     Networks
    </th>
    <th>
     DBMS &amp; Applications
    </th>
    <th>
     Database
    </th>
   </tr>
   <tr>
    <td style="text-align: left;">
     <ul>
      <li>
       Fire, flood, bombs
      </li>
      <li>
       Power loss or surge
      </li>
      <li>
       Electromagnetic interference and radiation
      </li>
      <li>
       Hardware failure of security mechanisms
      </li>
      <li>
       Equipment theft
      </li>
     </ul>
    </td>
    <td style="text-align: left;">
     <ul>
      <li>
       Wire tapping
      </li>
      <li>
       Cable breakage or disconnection
      </li>
      <li>
       Electromagnetic interference and radiation
      </li>
     </ul>
    </td>
    <td style="text-align: left;">
     <ul>
      <li>
       Software failure of security mechanisms
      </li>
      <li>
       Program alteration
      </li>
      <li>
       Program theft
      </li>
     </ul>
    </td>
    <td style="text-align: left;">
     <ul>
      <li>
       Unauthorized data I/O
      </li>
     </ul>
    </td>
   </tr>
  </table>
  <h3 id="security-solutions">
   <a>
    3.2.2. Security solutions
   </a>
  </h3>
  <p>
   This is what security typically looks like for enterprise databases:
  </p>
  <div class="figure">
   <img alt="Source: Simon Wang" src="illos/db-security.png"/>
   <p class="caption">
    <strong>
     Source:
    </strong>
    Simon Wang
   </p>
  </div>
  <h4 id="encryption">
   <a>
    3.2.2.1. Encryption
   </a>
  </h4>
  <p>
   Encryption protects the meaning of data despite an insecure environment. There are different approaches to encryption:
  </p>
  <ul>
   <li>
    <strong>
     Bit manipulation
    </strong>
    is substitution and permutation within blocks of N bits, decoded by a single key. This approach is used by the data encryption standard (DES; 64 bits) and advanced encryption standards (AES; 128/192/256 bits).
   </li>
   <li>
    <strong>
     Mathematical functions
    </strong>
    are used in public key encryption --- developed by Diffie &amp; Hellman in 1976, and operationalized as RSA in 1978. This approach uses two keys.
   </li>
   <li>
    <strong>
     Digital signatures
    </strong>
    are based on public key techniques, creating a unique, single-use string of symbols to represent (most often) an online transaction.
   </li>
  </ul>
  <h5 id="tde">
   <a>
    3.2.2.1.1. TDE
   </a>
  </h5>
  <p>
   SQL Server specifically offers transparent data encryption (TDE) so that data is protected if hardware is stolen. TDE stores database data in encrypted form, decrypts data as it's read, and encrypts data as it's written.
  </p>
  <h4 id="access-control">
   <a>
    3.2.2.2. Access control
   </a>
  </h4>
  <p>
   It's helpful to think about access in terms of principles (entities needing access); permissions (levels of access); and securables (objects needing protection). Access permissions specify
   <strong>
    who
   </strong>
   is allowed to do
   <strong>
    what
   </strong>
   (read, write, execute, share) to an object. Per DifferenceBetween.net (n.d.) and Steve DL (2014), there are several generic approaches to managing access permissions:
  </p>
  <ul>
   <li>
    Discretionary access control
    <strong>
     (DAC)
    </strong>
    permissions (widely used) are based on objects: each object has a list of users who may access it. This is a more flexible but also more admin labor-intensive approach, unless the data is meant to be goverened by individual users (e.g., Facebook).
   </li>
   <li>
    Mandatory access control
    <strong>
     (MAC)
    </strong>
    permissions (less common) are managed based on user group
    <a href="bash.html#manage-permissions">
     (like Linux).
    </a>
   </li>
   <li>
    In role-based access control
    <strong>
     (RBAC),
    </strong>
    user groups correspond to specific roles.
   </li>
  </ul>
  <h5 id="ownership-chaining">
   <a>
    3.2.2.2.1. Ownership chaining
   </a>
  </h5>
  <p>
   Instead of granting permissions to multiple tables, one can reduce administrative overhead by creating a view based on several tables and granting access to the view.
  </p>
  <h5 id="contained-database">
   <a>
    3.2.2.2.2. Contained database
   </a>
  </h5>
  <p>
   This is a SQL Server feature. A contained database handles its own authentication, metadata, etc., and is extremely useful for cloud computing.
  </p>
  <h4 id="preventing-sql-injections">
   <a>
    3.2.2.3. Preventing SQL injections
   </a>
  </h4>
  <p>
   SQL injections happen when database application developers use dynamic SQL statements in their code; hackers can use these channels to introduce their own malicious SQL statements. SQL injection is countered by user input validation:
  </p>
  <ul>
   <li>
    Use sp_executesql stored procedure
   </li>
   <li>
    Disallow comments:
    <code>
     -- /* */
    </code>
   </li>
   <li>
    Disallow punctuation:
    <code>
     ' ; ( )
    </code>
   </li>
   <li>
    Disallow binary data
   </li>
   <li>
    Validate XML against an XML schema
   </li>
  </ul>
  <h3 id="security-audits">
   <a>
    3.2.3. Security audits
   </a>
  </h3>
  <p>
   Check database logs to identify security problems, or conduct a more extensive audit. SQL Server provides a common criteria (C2) audit mode as well as SQL trace/SQL triggers (???).
  </p>
  <h2 id="backup">
   <a>
    3.3. Backup
   </a>
  </h2>
  <h1 id="sources">
   <a>
    4. Sources
   </a>
  </h1>
  <h2 id="cited">
   <a>
    4.1. Cited
   </a>
  </h2>
  <p>
   Chapple, M. (2016, November 29). Should I denormalize my database? ThoughtCo. Retrieved from
   <a class="uri" href="https://www.thoughtco.com/should-i-normalize-my-database-1019730">
    https://www.thoughtco.com/should-i-normalize-my-database-1019730
   </a>
  </p>
  <p>
   DifferenceBetween.net. (n.d.). Difference between MAC and DAC. Retrieved from
   <a class="uri" href="http://www.differencebetween.net/technology/software-technology/difference-between-mac-and-dac/">
    http://www.differencebetween.net/technology/software-technology/difference-between-mac-and-dac/
   </a>
  </p>
  <p>
   displayName. (2015, December 3). Are determinants and candidate keys same or different things? [Comment]. Stack Overflow. Message posted to
   <a class="uri" href="https://stackoverflow.com/questions/16706637/are-determinants-and-candidate-keys-same-or-different-things">
    https://stackoverflow.com/questions/16706637/are-determinants-and-candidate-keys-same-or-different-things
   </a>
  </p>
  <p>
   E/R model: types of attributes. (n.d.). Retrieved from the Database Management Wiki:
   <a class="uri" href="http://databasemanagement.wikia.com/wiki/E/R_Model:_Type_of_Attributes">
    http://databasemanagement.wikia.com/wiki/E/R_Model:_Type_of_Attributes
   </a>
  </p>
  <p>
   Connolly, T. &amp; Begg, C. (2015).
   <em>
    Database systems: A practical approach to design, implementation, and management
   </em>
   (6th ed.). New York City, NY: Pearson Education.
  </p>
  <p>
   Sheffield, W. (2012, October 12). Does a clustered index really physically store the rows in key order?
   <a class="uri" href="http://blog.waynesheffield.com/wayne/archive/2012/10/does-a-clustered-index-really-physically-store-the-rows-in-key-order/">
    http://blog.waynesheffield.com/wayne/archive/2012/10/does-a-clustered-index-really-physically-store-the-rows-in-key-order/
   </a>
  </p>
  <p>
   Sheldon, R. (2013, July 30). Columnstore indexes in SQL Server 2012.
   <em>
    Simple Talk.
   </em>
   Retrieved from
   <a class="uri" href="https://www.simple-talk.com/sql/database-administration/columnstore-indexes-in-sql-server-2012/">
    https://www.simple-talk.com/sql/database-administration/columnstore-indexes-in-sql-server-2012/
   </a>
  </p>
  <p>
   Sheldon, R. (2014, March 25). 14 SQL Server indexing questions you were too shy to ask.
   <em>
    Simple Talk.
   </em>
   Retrieved from
   <a class="uri" href="https://www.simple-talk.com/sql/performance/14-sql-server-indexing-questions-you-were-too-shy-to-ask/">
    https://www.simple-talk.com/sql/performance/14-sql-server-indexing-questions-you-were-too-shy-to-ask/
   </a>
  </p>
  <p>
   Steve DL. (2014, July 20). MAC vs DAC vs RBAC [forum post]. StackOverflow. Retrieved from
   <a class="uri" href="https://security.stackexchange.com/questions/63518/mac-vs-dac-vs-rbac">
    https://security.stackexchange.com/questions/63518/mac-vs-dac-vs-rbac
   </a>
  </p>
  <p>
   Sunderraman, R. (2012). Entity-relationship (ER) model. Retrieved from
   <a class="uri" href="http://tinman.cs.gsu.edu/~raj/4340/sp12/er.html">
    http://tinman.cs.gsu.edu/~raj/4340/sp12/er.html
   </a>
  </p>
  <p>
   Ullman, R. D. (2006). Relational database design. Retrieved from
   <a class="uri" href="http://infolab.stanford.edu/~ullman/fcdb/jw-notes06/reldesign.html">
    http://infolab.stanford.edu/~ullman/fcdb/jw-notes06/reldesign.html
   </a>
  </p>
  <p>
   Watt, A. (n.d.). Functional dependencies. In
   <em>
    Database design.
   </em>
   Retrieved from
   <a class="uri" href="https://opentextbc.ca/dbdesign/chapter/chapter-11-functional-dependencies/">
    https://opentextbc.ca/dbdesign/chapter/chapter-11-functional-dependencies/
   </a>
  </p>
  <p>
   Winand, M. (n.d.). Anatomy of a SQL index. Retrieved from
   <a class="uri" href="http://use-the-index-luke.com/sql/anatomy">
    http://use-the-index-luke.com/sql/anatomy
   </a>
  </p>
  <h2 id="references">
   <a>
    4.2. References
   </a>
  </h2>
  <ul>
   <li>
    <a href="http://databasemanagement.wikia.com/wiki/Main_Page">
     Database Management Wikia
    </a>
   </li>
   <li>
    <a href="http://use-the-index-luke.com/sql/table-of-contents">
     Use the index, Luke: A guide to database performance for developers
    </a>
   </li>
  </ul>
  <h2 id="read">
   <a>
    4.3. Read
   </a>
  </h2>
  <ul>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/RDB/SelfPaced/about">
     Intro. to Relational Databases
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/RA/SelfPaced/about">
     Relational Algebra
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/RD/SelfPaced/about">
     Relational Design Theory
    </a>
   </li>
   <li>
    <a href="http://www.lynda.com/Access-tutorials/Relational-Database-Fundamentals/145932-2.html">
     Relational Database Fundamentals
    </a>
   </li>
   <li>
    <a href="http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html">
     ORM is an offensive anti-pattern
    </a>
   </li>
   <li>
    <a href="http://www.lynda.com/Access-tutorials/Access-2016-Essential-Training/367064-2.html">
     Access 2016
    </a>
   </li>
  </ul>
  <h2>
   <a name="4.4.-unread">
    4.4. Unread
   </a>
  </h2>
  <ul>
   <li>
    <a class="uri" href="https://blogs.msdn.microsoft.com/plankytronixx/2010/10/22/crypto-primer-understanding-encryption-publicprivate-key-signatures-and-certificates/">
     https://blogs.msdn.microsoft.com/plankytronixx/2010/10/22/crypto-primer-understanding-encryption-publicprivate-key-signatures-and-certificates/
    </a>
   </li>
   <li>
    <a href="https://www.codecademy.com/articles/sql-rdbms">
     Overview of SQL RDBMS
    </a>
   </li>
   <li>
    <a href="http://coding-geek.com/how-databases-work/">
     How does a relational database work?
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/Indexes/SelfPaced/about">
     Indexes &amp; Transactions
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/Constraints/SelfPaced/about">
     Constraints &amp; Triggers
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/Views/SelfPaced/about">
     Views &amp; Authorization
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/OLAP/SelfPaced/about">
     OLAP
    </a>
   </li>
   <li>
    <a href="https://lagunita.stanford.edu/courses/DB/Recursion/SelfPaced/about">
     Recursion
    </a>
   </li>
   <li>
    <a href="http://databases.about.com/od/specificproducts/a/Database-Dependency.htm">
     Database dependency
    </a>
   </li>
   <li>
    <a href="https://www.codeschool.com/courses/the-magical-marvels-of-mongodb">
     CodeSchool - NoSQL with MongoDB
    </a>
   </li>
   <li>
    <a href="https://neo4j.com/developer/graph-db-vs-rdbms/">
     From relational to graph databases
    </a>
   </li>
   <li>
    <a href="https://en.wikipedia.org/wiki/Blockchain_(database)">
     Blockchain
    </a>
   </li>
   <li>
    <a href="https://news.ycombinator.com/item?id=9436847">
     Is Git a blockchain?
    </a>
   </li>
   <li>
    <a href="http://dataconomy.com/sql-vs-nosql-need-know/">
     SQL vs NoSQL
    </a>
   </li>
   <li>
    <a href="http://faculty.washington.edu/blabob/bob/eBooks/Beyond%20Relational%20(WP%20MarkLogic%202015).pdf">
     Beyond Relational
    </a>
   </li>
   <li>
    <a href="http://faculty.washington.edu/blabob/bob/eBooks/Why%20NoSQL%20(WP%20IBM).PDF">
     Why NoSQL
    </a>
   </li>
   <li>
    <a href="http://www.kdnuggets.com/2016/07/seven-steps-understanding-nosql-databases.html">
     7 steps to understanding NoSQL databases
    </a>
   </li>
   <li>
    <a href="http://apigee.com/about/blog/technology/nosql-noproblem-mapping-your-sql-thinking-nosql">
     Mapping your SQL thinking to NoSQL
    </a>
    -
    <a href="https://bigdatauniversity.com/courses/sql-access-on-hadoop-big-sql-v4/">
     BigSQL on Hadoop
    </a>
   </li>
   <li>
    <a href="http://faculty.washington.edu/blabob/bob/eBooks/Enterprise%20NoSQL%20for%20Dummies%20(eBook).pdf">
     Enterprise NoSQL for Dummies
    </a>
   </li>
   <li>
    <a href="http://graphdatabases.com/">
     Graph Databases
    </a>
   </li>
  </ul>
 </body>
</html>
