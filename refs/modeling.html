<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <meta content="text/css" http-equiv="Content-Style-Type"/>
  <meta content="pandoc" name="generator"/>
  <title>
   jtkovacs.github.io | modeling
  </title>
  <link href="../assets/styles/main.css" rel="stylesheet" type="text/css"/>
  <link href="../assets/styles/refs.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <p class="path">
   <a href="../pkb.html">
    pkb contents
   </a>
   &gt; modeling | just under 1727 words | updated 05/21/2017
  </p>
  <div class="TOC">
   <ul>
    <li>
     1.
     <a href="#overview-of-modeling">
      Overview of modeling
     </a>
     <ul>
      <li>
       1.1.
       <a href="#why-model">
        Why model?
       </a>
      </li>
      <li>
       1.2.
       <a href="#model-typologies">
        Model typologies
       </a>
      </li>
     </ul>
    </li>
    <li>
     2.
     <a href="#models-by-form-and-notation">
      Models by form and notation
     </a>
     <ul>
      <li>
       2.1.
       <a href="#flow-charts">
        Flow charts
       </a>
       <ul>
        <li>
         2.1.1.
         <a href="#nassi-schneiderman-n-s-diagram">
          Nassi-Schneiderman (N-S) diagram
         </a>
        </li>
       </ul>
      </li>
      <li>
       2.2.
       <a href="#entity-relationship-diagrams">
        Entity-relationship diagrams
       </a>
       <ul>
        <li>
         2.2.1.
         <a href="#erds-for-databases">
          ERDs for databases
         </a>
         <ul>
          <li>
           2.2.1.1.
           <a href="#bachmanncrows-foot-notation">
            Bachmann/crow's foot notation
           </a>
          </li>
          <li>
           2.2.1.2.
           <a href="#uml-notation">
            UML notation
           </a>
          </li>
         </ul>
        </li>
        <li>
         2.2.2.
         <a href="#data-flow-diagrams">
          Data flow diagrams
         </a>
        </li>
        <li>
         2.2.3.
         <a href="#use-case-diagrams">
          Use case diagrams
         </a>
        </li>
        <li>
         2.2.4.
         <a href="#deployment-diagrams">
          Deployment diagrams
         </a>
        </li>
       </ul>
      </li>
      <li>
       2.3.
       <a href="#object-oriented-modeling">
        Object-oriented modeling
       </a>
       <ul>
        <li>
         2.3.1.
         <a href="#object-modeling-technique">
          Object Modeling Technique
         </a>
        </li>
        <li>
         2.3.2.
         <a href="#activity-diagrams">
          Activity diagrams
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     3.
     <a href="#sources">
      Sources
     </a>
     <ul>
      <li>
       3.1.
       <a href="#cited">
        Cited
       </a>
      </li>
      <li>
       3.2.
       <a href="#references">
        References
       </a>
      </li>
      <li>
       3.3.
       <a href="#read">
        Read
       </a>
      </li>
      <li>
       3.4.
       <a href="#unread">
        Unread
       </a>
      </li>
     </ul>
    </li>
   </ul>
  </div>
  <p>
   <em>
    The following notes are largely based on Steirn (1999) and
    <a href="https://vserver1.cscs.lsa.umich.edu/~spage/">
     Scott Page's
    </a>
    Coursera class on
    <a href="https://www.coursera.org/course/modelthinking">
     Model Thinking.
    </a>
   </em>
  </p>
  <p>
   <em>
    Note that there's a lot of overlap between depicting a system and
    <a href="project-management.html">
     implementing one;
    </a>
    between depicting a process and
    <a href="process-improvement.html">
     improving it;
    </a>
    between modeling a problem and
    <a href="models.html">
     analyzing it;
    </a>
    between modeling a system and
    <a href="databases.html#database-design">
     modeling a database;
    </a>
    between model forms and
    <a href="information-architecture.html#kos-by-structure">
     knowledge organization structures.
    </a>
   </em>
  </p>
  <h1 id="overview-of-modeling">
   <a>
    1. Overview of modeling
   </a>
  </h1>
  <p>
   Because a model is a representation of a system, the model needs to include contextual metadata clarifying the date and/or version of the system it describes.
  </p>
  <h2 id="why-model">
   <a>
    1.1. Why model?
   </a>
  </h2>
  <p>
   Per Scott Page, modeling helps us:
  </p>
  <ul>
   <li>
    <strong>
     Be an intelligent citizen of the world.
    </strong>
    Models are everywhere, so full participation requires knowing them. They are "the new lingua franca" in nonprofits, businesses, politics, academia.
   </li>
   <li>
    <strong>
     Be a clearer thinker.
    </strong>
    Models are "wrong, but useful"; people make better decisions using a formal model versus either a single model, or multiple casual models. “You are a modeler … But typically, it is an implicit model in which the assumptions are hidden, their internal consistency is untested, their logical consequences are unknown, and their relation to data is unknown.”
    <ul>
     <li>
      <strong>
       Work through all the logical possibilities
      </strong>
      for parts; relationships between parts; logic
     </li>
     <li>
      <strong>
       Identify the general class of outcome:
      </strong>
      equilibrium, cycle, random, complex
     </li>
     <li>
      <strong>
       Identify logical bounds:
      </strong>
      "Models give us the conditions under which we can adjudicate" between ideas, e.g. contradictory folk proverbs.
      <em>
       When
      </em>
      are "two heads better than one"?
      <em>
       When
      </em>
      do "two cooks spoil the broth"?
     </li>
     <li>
      <strong>
       Reduce complexity.
      </strong>
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Understand and use data,
    </strong>
    turning it into knowledge.
    <ul>
     <li>
      <strong>
       See patterns
      </strong>
      and understand where they come from
     </li>
     <li>
      <strong>
       Make predictions
      </strong>
      (point or range/bounds)
     </li>
     <li>
      <strong>
       Make retrodictions
      </strong>
      (predict the past, when data is absent or when testing predictive models)
     </li>
     <li>
      <strong>
       See if something is missing,
      </strong>
      e.g. orbits makes us think that there’s a planet beyond our sight
     </li>
     <li>
      <strong>
       Strategize data collection
      </strong>
     </li>
     <li>
      <strong>
       Estimate unobservable parameters
      </strong>
      &amp; calibrate based on data
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Better decide, strategize, design, and act.
    </strong>
    <ul>
     <li>
      <strong>
       Make decisions
      </strong>
      (e.g., the Monty Hall door selection problem)
     </li>
     <li>
      <strong>
       Consider counterfactuals
      </strong>
     </li>
     <li>
      <strong>
       Identify and rank levers:
      </strong>
      where do we intervene to have an impact?
     </li>
     <li>
      <strong>
       Design experiments and institutions
      </strong>
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Communicate what we know very simply.
    </strong>
    “[M]odels can be the focal points of teams involving experts from many disciplines”
   </li>
   <li>
    <strong>
     Discover new things:
    </strong>
    "Models are fertile", i.e., they have multiple and unexpected uses. “Models can surprise us, make us curious, and lead to new questions. This is what I hate about exams. They only show that you can answer somebody else's question, when the most important thing is: Can you ask a new question?”
   </li>
  </ul>
  <h2 id="model-typologies">
   <a>
    1.2. Model typologies
   </a>
  </h2>
  <p>
   Models can have a general form (e.g. entity relationship diagram) somewhat corresponding to
   <a href="information-architecture.html#information-structures">
    information structures,
   </a>
   but be executable in different notations (e.g. Chen, crow's foot). This page organizes models by
   <strong>
    form and notation,
   </strong>
   following Steirn (1999), who seems very similar to Dennis et al. (2012):
  </p>
  <ul>
   <li>
    <strong>
     Functional
    </strong>
    (==flow chart?) models capture processes:
    <ul>
     <li>
      Use-case diagrams
     </li>
     <li>
      Activity diagrams
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Structural
    </strong>
    (==ERD?) models capture objects, their attributes, and their interactions:
    <ul>
     <li>
      CRC cards
     </li>
     <li>
      Class diagrams
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Behavioral
    </strong>
    (==object-oriented?) models capture even more detail about interactions:
    <ul>
     <li>
      Interaction diagrams
      <ul>
       <li>
        Sequence diagrams
       </li>
      </ul>
     </li>
     <li>
      Behavioral state machines
     </li>
     <li>
      Crude analysis
     </li>
    </ul>
   </li>
  </ul>
  <p>
   Smartdraw.com (n.d.):
  </p>
  <ul>
   <li>
    <strong>
     Graphs
    </strong>
    represent entities and relationships
    <ul>
     <li>
      Venn
     </li>
     <li>
      Flowchart
     </li>
     <li>
      Network diagram
     </li>
     <li>
      Genograms
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Charts
    </strong>
    represent data
    <ul>
     <li>
      Histogram
     </li>
     <li>
      Line graph
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Schematics
    </strong>
    represent the elements and architecture of a system
    <ul>
     <li>
      Circuit diagram
     </li>
     <li>
      Floorplan
     </li>
    </ul>
   </li>
  </ul>
  <p>
   Models could also be grouped by the
   <strong>
    business problems they solve
   </strong>
   (e.g. poor quality, lack of strategic direction, etc.); by
   <strong>
    domain of origin
   </strong>
   (models have been developed sequentially or in parallel by Taylorists, postwar Japanese manufacturers, industrial engineers, social scientists, and software developers); by
   <strong>
    practice area
   </strong>
   (different models may tend to be used in UX, database development, consulting, requirements management, etc.); by
   <strong>
    methodology
   </strong>
   (e.g. Agile, SDLC); or as they appear in
   <strong>
    stages of a process/lifecycle
   </strong>
   (e.g. identifying a problem, analyzing a problem, designing solutions, etc.):
  </p>
  <div class="figure">
   <img src="illos/models-by-analysis-vs-design.jpeg"/>
  </div>
  <h1 id="models-by-form-and-notation">
   <a>
    2. Models by form and notation
   </a>
  </h1>
  <h2 id="flow-charts">
   <a>
    2.1. Flow charts
   </a>
  </h2>
  <p>
   AKA decision flow charts, logic flow charts, and logical decision flow charts. Flow charts model
   <strong>
    decisions,
   </strong>
   a type of process. Languages that model processes more generally can also represent decisions.
  </p>
  <p>
   The basic elements of flow charts are available in MS Visio's language level diagrams stencil:
  </p>
  <ul>
   <li>
    <strong>
     Parallellograms
    </strong>
    for inputs
   </li>
   <li>
    <strong>
     Diamonds
    </strong>
    for decisions
   </li>
   <li>
    <strong>
     Rectangles
    </strong>
    for functions
   </li>
   <li>
    <strong>
     Hardcopy symbol
    </strong>
    (rectangle with wavy bottom edge) for outputs
   </li>
  </ul>
  <h3 id="nassi-schneiderman-n-s-diagram">
   <a>
    2.1.1. Nassi-Schneiderman (N-S) diagram
   </a>
  </h3>
  <p>
   AKA Chapin charts, structograms, structured flowcharts. Per Nassi and Shneiderman (1973), "We propose a flowchart language whose control structure is closer to that of language amenable to
   <strong>
    structured programming:"
   </strong>
  </p>
  <p>
   <img src="illos/N-S-diagram.png" width="250px"/>
  </p>
  <h2 id="entity-relationship-diagrams">
   <a>
    2.2. Entity-relationship diagrams
   </a>
  </h2>
  <p>
   All ERDs capture the entities in a system, along with their attributes and interrelationships; enhanced ERDs include superclasses and subclasses.
  </p>
  <h3 id="erds-for-databases">
   <a>
    2.2.1. ERDs for databases
   </a>
  </h3>
  <p>
   Per Dybka (2014), there are many notation styles:
  </p>
  <ul>
   <li>
    <strong>
     Crow's foot
    </strong>
   </li>
   <li>
    <strong>
     Martin
    </strong>
   </li>
   <li>
    <strong>
     UML
    </strong>
   </li>
   <li>
    <a href="../ILLOS/chens.png">
     Chen
    </a>
   </li>
   <li>
    <a href="../ILLOS/bakers.png">
     Baker
    </a>
   </li>
   <li>
    <a href="../ILLOS/arrow.png">
     Arrow
    </a>
   </li>
   <li>
    <a href="../ILLOS/idef1x.png">
     IDEF1X
    </a>
   </li>
  </ul>
  <h4 id="bachmanncrows-foot-notation">
   <a>
    2.2.1.1. Bachmann/crow's foot notation
   </a>
  </h4>
  <p>
   This is a notation that describes the optionality/modality/participation and cardinality/multiplicity of a relationship, so it can be used within other modeling systems. Crows-foot notation annotates relationships with the symbols:
  </p>
  <ul>
   <li>
    <strong>
     Open circle
    </strong>
    for optional participation (zero to many)
   </li>
   <li>
    <strong>
     Bar
    </strong>
    for mandatory participation (one to many)
   </li>
   <li>
    <strong>
     Crow-foot
    </strong>
    for many
   </li>
   <li>
    <strong>
     Bar
    </strong>
    for one
   </li>
  </ul>
  <p>
   Entity A is on the left, entity B is on the right. They are connected with an annotated line. Annotations on the right side of the line describe how A relates to B: for a single row in A, how many rows minimum and how many rows maximum could appear in B? Annotations on the left side of the line describe how B relates to A: for a single row in B, how many rows could appear in A?
  </p>
  <p>
   <img align="left" src="illos/crowsfoot.gif" width="350px"/>
  </p>
  <p>
   <img src="illos/EERD.png" style="padding-bottom:60px;" width="280px"/>
  </p>
  <h4 id="uml-notation">
   <a>
    2.2.1.2. UML notation
   </a>
  </h4>
  <p>
   Predates ER notation, but increasingly popular as a database modeling language; see
   <a href="UML.html">
    notes on UML.
   </a>
  </p>
  <p>
   <img src="illos/UML-EERD.png" width="450px"/>
  </p>
  <h3 id="data-flow-diagrams">
   <a>
    2.2.2. Data flow diagrams
   </a>
  </h3>
  <p>
   Per Le Vie and Donald (2000), "Data flow diagrams have replaced flowcharts and pseudocode as the tool of choice for showing program design" --- at least in the early stages of system design --- because they show data along with program functions that transform the data. DFDs are highly compatible with object-oriented programming and design. Gane-Sarson and Yourdon-Coad notations are slightly different, but both use the following elements:
  </p>
  <ul>
   <li>
    <strong>
     Rectangles
    </strong>
    to represent external interactors AKA agents, terminators, sources, sinks
   </li>
   <li>
    <strong>
     Lines
    </strong>
    to represent data flows, annotated with descriptive labels and arrows for directionality
   </li>
   <li>
    <strong>
     Circles
    </strong>
    to represent system processes (named with descriptive verbs) that transform the data
   </li>
   <li>
    <strong>
     Open rectangles
    </strong>
    to represent internal data stores
   </li>
  </ul>
  <div class="figure">
   <img src="illos/DFD.jpg"/>
  </div>
  <p>
   DFDs are created for different levels of the system, starting with the
   <strong>
    context diagram
   </strong>
   (the most general view), proceeding to
   <strong>
    level 0 diagrams
   </strong>
   and
   <strong>
    level 1 diagrams.
   </strong>
   Per Le Vie and Donald (2000), only certain data flows (usually!) are valid:
  </p>
  <ul>
   <li>
    Between a process and an entity (in either direction)
   </li>
   <li>
    Between a process and a data store (in either direction)
   </li>
   <li>
    Between two processes that can only run simultaneously
   </li>
  </ul>
  <h3 id="use-case-diagrams">
   <a>
    2.2.3. Use case diagrams
   </a>
  </h3>
  <p>
   UML use case diagrams are used to organize
   <a href="project-management.html#use-cases">
    use cases.
   </a>
   The basic elements:
  </p>
  <ul>
   <li>
    <strong>
     Ovals
    </strong>
    for use cases
    <ul>
     <li>
      <strong>
       Shaded black
      </strong>
      for misuse cases
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Lines
    </strong>
    for relationships; may be annotated
    <ul>
     <li>
      &lt;&lt;include&gt;&gt; (routinely shared functionality)
     </li>
     <li>
      &lt;&lt;extend&gt;&gt; (exceptional scenario)
     </li>
    </ul>
   </li>
  </ul>
  <p>
   <img src="illos/use-case-diagram.gif" width="350px"/>
  </p>
  <h3 id="deployment-diagrams">
   <a>
    2.2.4. Deployment diagrams
   </a>
  </h3>
  <p>
   Per Ambler (n.d. c), deployment diagrams depict the hardware and software components of a system. Deployment diagrams are slightly more detailed than
   <a href="http://agilemodeling.com/artifacts/networkDiagram.htm">
    network diagrams,
   </a>
   and include:
  </p>
  <ul>
   <li>
    <strong>
     Lines
    </strong>
    with &lt;&lt;annotations&gt;&gt; for relationships
   </li>
   <li>
    <strong>
     3D boxes
    </strong>
    for software or hardware "nodes"
    <ul>
     <li>
      Nodes can contain other nodes
     </li>
     <li>
      Nodes can be annotated
      <ul>
       <li>
        If hardware, label with &lt;&lt;device&gt;&gt;
       </li>
       <li>
        {propery=value, property=value, ...}
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
  <div class="figure">
   <img src="illos/deployment-diagram.jpg"/>
  </div>
  <h2 id="object-oriented-modeling">
   <a>
    2.3. Object-oriented modeling
   </a>
  </h2>
  <p>
   OO models show
   <strong>
    inheritance
   </strong>
   as well as decisions, relationships, and processes. Per Steirn (1999), several earlier methods (Shlaer/Mellor, Rumbaugh's Object Modeling Technique (OMT), Booch) were subsumed by UML in 1997.
  </p>
  <h3 id="object-modeling-technique">
   <a>
    2.3.1. Object Modeling Technique
   </a>
  </h3>
  <p>
   Per La Vie and Donald (2000), OMT produces three views of a system: "The
   <em>
    Object Model
   </em>
   describes the static system components and is modeled using object diagrams. The
   <em>
    Dynamic Model
   </em>
   describes the dynamic system components that change over time and are modeled using state diagrams. The
   <em>
    Functional Model
   </em>
   describes operations performed on data in a system and uses data flow diagrams."
  </p>
  <h3 id="activity-diagrams">
   <a>
    2.3.2. Activity diagrams
   </a>
  </h3>
  <p>
   Activity diagrams are similar to flowcharts and data flow diagrams, since they focus on depicting a
   <em>
    process
   </em>
   corresponding to a specific
   <a href="project-management.html#use-cases-&amp;-requirements-definition-reports">
    use case
   </a>
   or
   <a href="project-management.html#use-scenarios">
    usage scenario.
   </a>
   Per Ambler (n.d. b), activity diagrams use the following UML elements:
  </p>
  <ul>
   <li>
    <strong>
     Rounded rectangle
    </strong>
    to indicate activities
   </li>
   <li>
    <strong>
     Rectangle
    </strong>
    to capture explanatory notes
    <ul>
     <li>
      <strong>
       Dotted line
      </strong>
      to connect notes to relevant entities
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Oval
    </strong>
    to indicate that a use case is being covered
    <ul>
     <li>
      <strong>
       Rake
      </strong>
      annotating an activity, to indicate it's described by its own activity diagram
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Lines
    </strong>
    for flows
    <ul>
     <li>
      <strong>
       Black bar
      </strong>
      for forks and joins (to capture parallel processes: AND)
     </li>
     <li>
      <strong>
       Diamonds
      </strong>
      for conditional branching and merging (OR)
      <ul>
       <li>
        <strong>
         Bracketed text annotation
        </strong>
        of a flow to denote a logical condition that must be satisfied
       </li>
      </ul>
     </li>
     <li>
      <strong>
       Solid circle
      </strong>
      to indicate the starting node
     </li>
     <li>
      <strong>
       Solid circle with halo
      </strong>
      to indicate terminal node/s
      <br/>
     </li>
     <li>
      <strong>
       Halo around X
      </strong>
      to indicate unsuccessful end of process
     </li>
    </ul>
   </li>
   <li>
    <strong>
     Swimlanes
    </strong>
    to capture which actor performs the activity
   </li>
  </ul>
  <p>
   <img src="illos/activity-diagram.jpg" width="580px"/>
  </p>
  <h1 id="sources">
   <a>
    3. Sources
   </a>
  </h1>
  <h2 id="cited">
   <a>
    3.1. Cited
   </a>
  </h2>
  <p>
   Ambler, S. (n.d. a). Agile models distilled: Potential artifacts for agile modeling. Retrieved from
   <a class="uri" href="http://www.agilemodeling.com/artifacts/">
    http://www.agilemodeling.com/artifacts/
   </a>
  </p>
  <p>
   Ambler, S. (n.d. b). UML 2 activity diagrams: An Agile introduction. Retrieved from
   <a class="uri" href="http://www.agilemodeling.com/artifacts/activityDiagram.htm">
    http://www.agilemodeling.com/artifacts/activityDiagram.htm
   </a>
  </p>
  <p>
   Ambler, S. (n.d. c). UML 2 deployment diagrams: An Agile introduction. Retrieved from
   <a class="uri" href="http://www.agilemodeling.com/artifacts/deploymentDiagram.htm">
    http://www.agilemodeling.com/artifacts/deploymentDiagram.htm
   </a>
  </p>
  <p>
   Dybka, P. (2014). ERD notations in data modeling. Vertabelo Academy. Retrieved from
   <a class="uri" href="http://www.vertabelo.com/blog/technical-articles/comparison-of-erd-notations">
    http://www.vertabelo.com/blog/technical-articles/comparison-of-erd-notations
   </a>
  </p>
  <p>
   Dennis, A., Haley Wixom, B., &amp; Tegarden, D. (2012). Requirements determination. In
   <em>
    Systems analysis and design: An object oriented approach with UML
   </em>
   (4th ed., pp. 109–152). Hoboken, NJ: Wiley.
  </p>
  <p>
   Le Vie, D. S., &amp; Donald, S. (2000). Understanding data flow diagrams. In
   <em>
    Annual Conference - Society for Technical Communication,
   </em>
   47, pp. 396–401.
  </p>
  <p>
   Meadows, D. H., &amp; Wright, D. (2008).
   <em>
    Thinking in systems: A primer.
   </em>
   White River Junction, Vt.: Chelsea Green Pub.
  </p>
  <p>
   Nassi, I., &amp; Shneiderman, B. (1973). Flowchart techniques for structured programming.
   <em>
    SIGPLAN Not., 8
   </em>
   (8), 12–26. Retrieved from
   <a class="uri" href="https://www.cs.umd.edu/hcil/members/bshneiderman/nsd/1973.pdf">
    https://www.cs.umd.edu/hcil/members/bshneiderman/nsd/1973.pdf
   </a>
  </p>
  <p>
   Smartdraw.com. (n.d.). Diagrams. Retrieved from
   <a class="uri" href="https://www.smartdraw.com/diagrams/?exp=ste">
    https://www.smartdraw.com/diagrams/?exp=ste
   </a>
  </p>
  <p>
   Stiern, K. (1999). Comparison of diagramming methods. Retrieved from
   <a class="uri" href="http://www.umsl.edu/~sauterv/analysis/dfd/DiagrammingMethods.html">
    http://www.umsl.edu/~sauterv/analysis/dfd/DiagrammingMethods.html
   </a>
  </p>
  <h2 id="references">
   <a>
    3.2. References
   </a>
  </h2>
  <ul>
   <li>
    <a class="uri" href="http://creately.com/blog/diagrams/uml-diagram-types-examples/">
     http://creately.com/blog/diagrams/uml-diagram-types-examples/
    </a>
   </li>
  </ul>
  <h2 id="read">
   <a>
    3.3. Read
   </a>
  </h2>
  <h2>
   <a name="3.4.-unread">
    3.4. Unread
   </a>
  </h2>
 </body>
</html>
